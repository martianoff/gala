package test

import (
    "fmt"
    "os"
    "time"
)

// T is the test context, similar to Go's *testing.T.
// It tracks test state and provides assertion and logging methods.
type T struct {
    name     string
    var failed   bool
    var skipped  bool
}

// newT creates a new test context with the given name.
func newT(name string) T {
    return T(name = name, failed = false, skipped = false)
}

// Name returns the name of the test.
func (t T) Name() string = t.name

// Failed returns whether the test has failed.
func (t T) Failed() bool = t.failed

// Skipped returns whether the test was skipped.
func (t T) Skipped() bool = t.skipped

// Fail marks the test as failed.
func (t T) Fail() T {
    return T(name = t.name, failed = true, skipped = t.skipped)
}

// Skip marks the test as skipped.
func (t T) Skip() T {
    return T(name = t.name, failed = t.failed, skipped = true)
}

// Log prints a message to the test output.
func (t T) Log(msg string) {
    fmt.Printf("    %s\n", msg)
}

// Error logs an error message and marks the test as failed.
func (t T) Error(msg string) T {
    fmt.Printf("    ERROR: %s\n", msg)
    return T(name = t.name, failed = true, skipped = t.skipped)
}

// Fatal logs an error message, marks the test as failed, and stops execution.
func (t T) Fatal(msg string) {
    fmt.Printf("    FATAL: %s\n", msg)
    panic(fmt.Sprintf("Test %s fatal error: %s", t.name, msg))
}

// Run runs a subtest with the given name and function.
// This enables table-driven testing patterns.
// Panics in subtests are recovered and reported as failures.
func (t T) Run(name string, f func(T) T) T {
    var subT = newT(t.name + "/" + name)
    fmt.Printf("=== RUN   %s\n", subT.name)

    var start = time.Now()
    var result = runTest(subT, f)
    var elapsed = time.Since(start)

    if result.failed {
        fmt.Printf("--- FAIL: %s (%.3fs)\n", subT.name, elapsed.Seconds())
        return T(name = t.name, failed = true, skipped = t.skipped)
    } else if result.skipped {
        fmt.Printf("--- SKIP: %s (%.3fs)\n", subT.name, elapsed.Seconds())
        return t
    } else {
        fmt.Printf("--- PASS: %s (%.3fs)\n", subT.name, elapsed.Seconds())
        return t
    }
}

// runTest runs a test function with panic recovery.
// If the function panics, the panic is caught and reported as a test failure.
func runTest(t T, f func(T) T) T {
    val result = Try[T](() => f(t))
    if result.IsSuccess() {
        return result.Get()
    }
    return t.Error(fmt.Sprintf("PANIC: %v", result.GetError()))
}

// ============================================================================
// Test Runner
// ============================================================================

// TestFunc represents a test function that takes a T.
type TestFunc struct {
    Name string
    F    func(T) T
}

// Run executes the test function and returns the result.
func (tf TestFunc) Run() T {
    var t = newT(tf.Name)
    fmt.Printf("=== RUN   %s\n", t.name)

    var start = time.Now()
    var result = runTest(t, tf.F)
    var elapsed = time.Since(start)

    // Print result
    if result.failed {
        fmt.Printf("--- FAIL: %s (%.3fs)\n", t.name, elapsed.Seconds())
    } else if result.skipped {
        fmt.Printf("--- SKIP: %s (%.3fs)\n", t.name, elapsed.Seconds())
    } else {
        fmt.Printf("--- PASS: %s (%.3fs)\n", t.name, elapsed.Seconds())
    }
    return result
}

// RunTests runs all provided test functions and exits with appropriate code.
// This is the main entry point for running tests.
func RunTests(tests ...TestFunc) {
    var passed = 0
    var failed = 0
    var skipped = 0

    fmt.Println("=== STARTING TESTS ===")
    for i := 0; i < len(tests); i++ {
        var test = tests[i]
        var result = test.Run()
        if result.failed {
            failed++
        } else if result.skipped {
            skipped++
        } else {
            passed++
        }
    }

    fmt.Println()
    fmt.Println("=== RESULTS ===")
    fmt.Printf("Passed: %d, Failed: %d, Skipped: %d\n", passed, failed, skipped)

    if failed > 0 {
        fmt.Println("FAIL")
        os.Exit(1)
    }
    fmt.Println("PASS")
}
