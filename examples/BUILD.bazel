load("//:gala.bzl", "gala_binary", "gala_library", "gala_test")

filegroup(
    name = "gala_sources",
    srcs = [
        "lib/generic.gala",
        "mathlib/math.gala",
        "multi_file/greeter.gala",
        "multi_file/main.gala",
        "multi_file_lib/ops.gala",
        "multi_file_lib/types.gala",
        "multi_file_types/main.gala",
        "multi_file_types/model.gala",
        "multi_file_option/lookup.gala",
        "multi_file_option/main.gala",
        "struct_field_unwrap/main.gala",
        "struct_field_unwrap/types.gala",
        "foldleft_method/main.gala",
    ],
    visibility = ["//visibility:public"],
)

gala_library(
    name = "mathlib",
    src = "mathlib/math.gala",
    importpath = "martianoff/gala/examples/mathlib",
    visibility = ["//visibility:public"],
)

gala_library(
    name = "lib",
    src = "lib/generic.gala",
    importpath = "martianoff/gala/examples/lib",
    visibility = ["//visibility:public"],
)

gala_test(
    name = "hello",
    src = "hello.gala",
    expected = "hello.out",
)

gala_test(
    name = "with_main",
    src = "with_main.gala",
    expected = "with_main.out",
)

gala_test(
    name = "complex",
    src = "complex.gala",
    expected = "complex.out",
)

gala_test(
    name = "bool_operator",
    src = "bool_operator.gala",
    expected = "bool_operator.out",
)

gala_test(
    name = "imports",
    src = "imports.gala",
    expected = "imports.out",
)

gala_test(
    name = "use_lib",
    src = "use_lib.gala",
    expected = "use_lib.out",
    deps = [":mathlib"],
)

gala_test(
    name = "multi_vars",
    src = "multi_vars.gala",
    expected = "multi_vars.out",
)

gala_test(
    name = "struct_features",
    src = "struct_features.gala",
    expected = "struct_features.out",
)

gala_test(
    name = "copy_and_equal",
    src = "copy_and_equal.gala",
    expected = "copy_and_equal.out",
)

gala_test(
    name = "option_complex",
    src = "option_complex.gala",
    expected = "option_complex.out",
)

gala_test(
    name = "generic_methods",
    src = "generic_methods.gala",
    expected = "generic_methods.out",
)

gala_test(
    name = "generic_method_constraint",
    src = "generic_method_constraint.gala",
    expected = "generic_method_constraint.out",
)

gala_test(
    name = "match_extractors",
    src = "match_extractors.gala",
    expected = "match_extractors.out",
)

gala_test(
    name = "tuple",
    src = "tuple.gala",
    expected = "tuple.out",
)

gala_test(
    name = "either",
    src = "either.gala",
    expected = "either.out",
)

gala_test(
    name = "apply_method",
    src = "apply_method.gala",
    expected = "apply_method.out",
)

gala_test(
    name = "option_apply_unapply",
    src = "option_apply_unapply.gala",
    expected = "option_apply_unapply.out",
)

gala_test(
    name = "type_match",
    src = "type_match.gala",
    expected = "type_match.out",
)

gala_test(
    name = "nested_type_match",
    src = "nested_type_match.gala",
    expected = "nested_type_match.out",
)

gala_test(
    name = "interface",
    src = "interface.gala",
    expected = "interface.out",
)

gala_test(
    name = "generic_interface",
    src = "generic_interface.gala",
    expected = "generic_interface.out",
)

gala_test(
    name = "generic_wrap_match",
    src = "generic_wrap_match.gala",
    expected = "generic_wrap_match.out",
)

gala_test(
    name = "pattern_match_filter",
    src = "pattern_match_filter.gala",
    expected = "pattern_match_filter.out",
)

gala_test(
    name = "use_lib_generic",
    src = "use_lib_generic.gala",
    expected = "use_lib_generic.out",
    deps = [":lib"],
)

gala_test(
    name = "use_lib_qualified",
    src = "use_lib_qualified.gala",
    expected = "use_lib_generic.out",
    deps = [":lib"],
)

gala_test(
    name = "use_lib_alias",
    src = "use_lib_alias.gala",
    expected = "use_lib_generic.out",
    deps = [":lib"],
)

gala_test(
    name = "unwrapping",
    src = "unwrapping.gala",
    expected = "unwrapping.out",
)

gala_test(
    name = "hm_inference",
    src = "hm_inference.gala",
    expected = "hm_inference.out",
)

gala_test(
    name = "hm_unwrapping",
    src = "hm_unwrapping.gala",
    expected = "hm_unwrapping.out",
)

gala_test(
    name = "hm_generic_unwrapping",
    src = "hm_generic_unwrapping.gala",
    expected = "hm_unwrapping.out",
)

gala_test(
    name = "hm_generic_identity_unwrapping",
    src = "hm_generic_identity_unwrapping.gala",
    expected = "hm_generic_identity_unwrapping.out",
)

gala_test(
    name = "hm_advanced_unwrapping",
    src = "hm_advanced_unwrapping.gala",
    expected = "hm_unwrapping.out",
)

gala_test(
    name = "if_else_unwrapping",
    src = "if_else_unwrapping.gala",
    expected = "if_else_unwrapping.out",
)

gala_test(
    name = "unapply_inference",
    src = "unapply_inference.gala",
    expected = "unapply_inference.out",
)

gala_test(
    name = "generic_method_cycle",
    src = "generic_method_cycle.gala",
    expected = "generic_method_cycle.out",
)

gala_test(
    name = "tuple_syntax",
    src = "tuple_syntax.gala",
    expected = "tuple_syntax.out",
)

gala_test(
    name = "tuple_field_access",
    src = "tuple_field_access.gala",
    expected = "tuple_field_access.out",
    deps = ["//collection_immutable"],
)

gala_test(
    name = "list_pattern_match",
    src = "list_pattern_match.gala",
    expected = "list_pattern_match.out",
    deps = ["//collection_immutable"],
)

gala_test(
    name = "seq_pattern_match",
    src = "seq_pattern_match.gala",
    expected = "seq_pattern_match.out",
    deps = ["//collection_immutable"],
)

gala_test(
    name = "custom_seq_pattern",
    src = "custom_seq_pattern.gala",
    expected = "custom_seq_pattern.out",
    deps = ["//go_interop"],
)

gala_test(
    name = "mutable_collections",
    src = "mutable_collections.gala",
    expected = "mutable_collections.out",
    deps = ["//collection_mutable"],
)

gala_test(
    name = "try_basic",
    src = "try_basic.gala",
    expected = "try_basic.out",
)

# Temporarily enabled for debugging
gala_test(
    name = "try_recovery",
    src = "try_recovery.gala",
    expected = "try_recovery.out",
)

gala_test(
    name = "lambda_type_inference",
    src = "lambda_type_inference.gala",
    expected = "lambda_type_inference.out",
)

gala_test(
    name = "language_ergonomics",
    src = "language_ergonomics.gala",
    expected = "language_ergonomics.out",
    deps = ["//collection_immutable"],
)

gala_test(
    name = "expr_body_multiline_lambda",
    src = "expr_body_multiline_lambda.gala",
    expected = "expr_body_multiline_lambda.out",
)

gala_test(
    name = "hashmap",
    src = "hashmap.gala",
    expected = "hashmap.out",
    deps = [
        "//collection_immutable",
        "//collection_mutable",
    ],
)

gala_test(
    name = "hashmap_sorted_nonorderable",
    src = "hashmap_sorted_nonorderable.gala",
    expected = "hashmap_sorted_nonorderable.out",
    deps = [
        "//collection_immutable",
    ],
)

gala_test(
    name = "partial_function",
    src = "partial_function.gala",
    expected = "partial_function.out",
    deps = [
        "//collection_immutable",
    ],
)

gala_test(
    name = "pf_repro",
    src = "pf_repro.gala",
    expected = "pf_repro.out",
    deps = [
        "//collection_immutable",
    ],
)

gala_test(
    name = "callback_generic_param",
    src = "callback_generic_param.gala",
    expected = "callback_generic_param.out",
)

# TODO: Fix match expression interface return type compatibility
# gala_test(
#     name = "match_interface_return",
#     src = "match_interface_return.gala",
#     expected = "match_interface_return.out",
# )

gala_test(
    name = "future_pattern_match",
    src = "future_pattern_match.gala",
    expected = "future_pattern_match.out",
    deps = [
        "//collection_immutable",
        "//concurrent",
    ],
)

gala_test(
    name = "extractor_type_inference",
    src = "extractor_type_inference.gala",
    expected = "extractor_type_inference.out",
    deps = ["//concurrent"],
)

gala_test(
    name = "execution_context",
    src = "execution_context.gala",
    expected = "execution_context.out",
    deps = [
        "//collection_immutable",
        "//concurrent",
    ],
)

gala_test(
    name = "block_lambda_return",
    src = "block_lambda_return.gala",
    expected = "block_lambda_return.out",
)

gala_test(
    name = "pointer_semantics",
    src = "pointer_semantics.gala",
    expected = "pointer_semantics.out",
)

gala_test(
    name = "func_struct_field",
    src = "func_struct_field.gala",
    expected = "func_struct_field.out",
)

gala_test(
    name = "match_generic_inference",
    src = "match_generic_inference.gala",
    expected = "match_generic_inference.out",
)

# Transpiler issue repro tests
gala_test(
    name = "tuple_field_unwrap",
    src = "tuple_field_unwrap.gala",
    expected = "tuple_field_unwrap.out",
)

gala_test(
    name = "lambda_return_generic",
    src = "lambda_return_generic.gala",
    expected = "lambda_return_generic.out",
)

gala_test(
    name = "return_match",
    src = "return_match.gala",
    expected = "return_match.out",
)

gala_test(
    name = "tuple_shorthand_generic",
    src = "tuple_shorthand_generic.gala",
    expected = "tuple_shorthand_generic.out",
)

gala_test(
    name = "tuple_shorthand_mutable",
    src = "tuple_shorthand_mutable.gala",
    expected = "tuple_shorthand_mutable.out",
)

gala_test(
    name = "tuple_shorthand_array_index",
    src = "tuple_shorthand_array_index.gala",
    expected = "tuple_shorthand_array_index.out",
    deps = ["//go_interop"],
)

# Regression test for std type qualification in lambda parameters
gala_test(
    name = "std_type_in_lambda",
    src = "std_type_in_lambda.gala",
    expected = "std_type_in_lambda.out",
)

# Regression test for Tuple pattern match type inference
gala_test(
    name = "tuple6_pattern_match",
    src = "tuple6_pattern_match.gala",
    expected = "tuple6_pattern_match.out",
)

# Regression test for implicit return of if-else expression in block lambda
gala_test(
    name = "if_else_implicit_return",
    src = "if_else_implicit_return.gala",
    expected = "if_else_implicit_return.out",
    deps = ["//stream"],
)

# Tuple destructuring: val (a, b) = tuple
gala_test(
    name = "tuple_destructuring",
    src = "tuple_destructuring.gala",
    expected = "tuple_destructuring.out",
)

# Nested tuple destructuring: val (left, right) = ((1, 2), (3, 4))
gala_test(
    name = "nested_tuple_destruct",
    src = "nested_tuple_destruct.gala",
    expected = "nested_tuple_destruct.out",
)

# Short tuple syntax as function arguments
gala_test(
    name = "tuple_as_argument",
    src = "tuple_as_argument.gala",
    expected = "tuple_as_argument.out",
    deps = [
        "//collection_immutable",
        "//stream",
    ],
)

gala_test(
    name = "for_loops",
    src = "for_loops.gala",
    expected = "for_loops.out",
    deps = ["//go_interop"],
)

gala_test(
    name = "variadic_functions",
    src = "variadic_functions.gala",
    expected = "variadic_functions.out",
)

gala_test(
    name = "inc_dec",
    src = "inc_dec.gala",
    expected = "inc_dec.out",
)

gala_test(
    name = "try_panic_recovery",
    src = "try_panic_recovery.gala",
    expected = "try_panic_recovery.out",
)

gala_test(
    name = "sealed_types",
    src = "sealed_types.gala",
    expected = "sealed_types.out",
)

gala_test(
    name = "nested_match",
    src = "nested_match.gala",
    expected = "nested_match.out",
)

gala_test(
    name = "sealed_shared_fields",
    src = "sealed_shared_fields.gala",
    expected = "sealed_shared_fields.out",
)

gala_test(
    name = "sealed_recursive",
    src = "sealed_recursive.gala",
    expected = "sealed_recursive.out",
)

gala_test(
    name = "sealed_field_clash",
    src = "sealed_field_clash.gala",
    expected = "sealed_field_clash.out",
)

# Documentation verification tests (GALA.MD)
gala_test(
    name = "doc_verify_gala_md_basics",
    src = "doc_verify/gala_md_basics.gala",
    expected = "doc_verify/gala_md_basics.out",
)

gala_test(
    name = "doc_verify_gala_md_patterns",
    src = "doc_verify/gala_md_patterns.gala",
    expected = "doc_verify/gala_md_patterns.out",
)

gala_test(
    name = "doc_verify_gala_md_monads",
    src = "doc_verify/gala_md_monads.gala",
    expected = "doc_verify/gala_md_monads.out",
    deps = ["//go_interop"],
)

gala_test(
    name = "doc_verify_stream_md_examples",
    src = "doc_verify/stream_md_examples.gala",
    expected = "doc_verify/stream_md_examples.out",
    deps = ["//stream"],
)

gala_test(
    name = "doc_verify_examples_md",
    src = "doc_verify/examples_md.gala",
    expected = "doc_verify/examples_md.out",
    deps = ["//go_interop"],
)

gala_test(
    name = "doc_verify_immutable_collections_md",
    src = "doc_verify/immutable_collections_md.gala",
    expected = "doc_verify/immutable_collections_md.out",
    deps = ["//collection_immutable"],
)

gala_test(
    name = "doc_verify_mutable_collections_md",
    src = "doc_verify/mutable_collections_md.gala",
    expected = "doc_verify/mutable_collections_md.out",
    deps = [
        "//collection_mutable",
        "//go_interop",
    ],
)

gala_test(
    name = "doc_verify_concurrent_md",
    src = "doc_verify/concurrent_md.gala",
    expected = "doc_verify/concurrent_md.out",
    deps = ["//concurrent"],
)

gala_test(
    name = "doc_verify_string_utils_md",
    src = "doc_verify/string_utils_md.gala",
    expected = "doc_verify/string_utils_md.out",
    deps = ["//string_utils"],
)

gala_test(
    name = "doc_verify_time_utils_md",
    src = "doc_verify/time_utils_md.gala",
    expected = "doc_verify/time_utils_md.out",
    deps = ["//time_utils"],
)

# Regression test for FIX-002: unused extracted variables in match branches
gala_test(
    name = "unused_match_vars",
    src = "unused_match_vars.gala",
    expected = "unused_match_vars.out",
)

gala_test(
    name = "kvstore",
    src = "kvstore.gala",
    expected = "kvstore.out",
    deps = [
        "//collection_immutable",
        "//time_utils",
    ],
)

# Unary minus operator
gala_test(
    name = "unary_minus",
    src = "unary_minus.gala",
    expected = "unary_minus.out",
)

# Either Map/FlatMap
gala_test(
    name = "either_map_flatmap",
    src = "either_map_flatmap.gala",
    expected = "either_map_flatmap.out",
)

# Sealed type wildcard catch-all
gala_test(
    name = "sealed_wildcard",
    src = "sealed_wildcard.gala",
    expected = "sealed_wildcard.out",
)

# MkString on collections
gala_test(
    name = "mkstring",
    src = "mkstring.gala",
    expected = "mkstring.out",
    deps = [
        "//collection_immutable",
    ],
)

# Sorted API on collections
gala_test(
    name = "sorted",
    src = "sorted.gala",
    expected = "sorted.out",
    deps = [
        "//collection_immutable",
    ],
)

# TreeMap examples (immutable + mutable)
gala_test(
    name = "treemap",
    src = "treemap.gala",
    expected = "treemap.out",
    deps = [
        "//collection_immutable",
        "//collection_mutable",
    ],
)

# Sorted API on mutable collections
gala_test(
    name = "sorted_mutable",
    src = "sorted_mutable.gala",
    expected = "sorted_mutable.out",
    deps = [
        "//collection_mutable",
    ],
)

# Tuple String() methods
gala_test(
    name = "tuple_string",
    src = "tuple_string.gala",
    expected = "tuple_string.out",
)

# FIX-007 verification: tuple return type should not widen to any
gala_test(
    name = "tuple_return_type",
    src = "tuple_return_type.gala",
    expected = "tuple_return_type.out",
)

# Multi-file binary test (FIX-004 verification)
gala_test(
    name = "multi_file",
    srcs = [
        "multi_file/greeter.gala",
        "multi_file/main.gala",
    ],
    expected = "multi_file/multi_file.out",
)

# Multi-file with cross-file types: structs, sealed types, pattern matching
gala_test(
    name = "multi_file_types",
    srcs = [
        "multi_file_types/model.gala",
        "multi_file_types/main.gala",
    ],
    expected = "multi_file_types/multi_file_types.out",
)

# Multi-file library (non-main package with cross-file types)
gala_library(
    name = "multi_file_lib",
    srcs = [
        "multi_file_lib/types.gala",
        "multi_file_lib/ops.gala",
    ],
    importpath = "martianoff/gala/examples/multi_file_lib",
    visibility = ["//visibility:public"],
)

# Consumer of multi-file library
gala_test(
    name = "use_multi_file_lib",
    src = "use_multi_file_lib.gala",
    expected = "use_multi_file_lib.out",
    deps = [":multi_file_lib"],
)

# Multi-file Option test (FIX-001 verification: Some/None in multi-file mode)
gala_test(
    name = "multi_file_option",
    srcs = [
        "multi_file_option/lookup.gala",
        "multi_file_option/main.gala",
    ],
    expected = "multi_file_option/multi_file_option.out",
)

# Struct field auto-unwrapping when passed to functions (FIX-005 verification)
gala_test(
    name = "struct_field_unwrap",
    srcs = [
        "struct_field_unwrap/types.gala",
        "struct_field_unwrap/main.gala",
    ],
    expected = "struct_field_unwrap/struct_field_unwrap.out",
)

# FIX-004 verification: val multi-return from single Go function call
gala_test(
    name = "val_multi_return",
    src = "val_multi_return.gala",
    expected = "val_multi_return.out",
)

# FoldLeft method call (FIX-006 verification: method not transpiled as free function)
gala_test(
    name = "foldleft_method",
    src = "foldleft_method/main.gala",
    expected = "foldleft_method/foldleft_method.out",
    deps = ["//collection_immutable"],
)

# FIX-015 verification: sealed type named-arg construction in multi-file mode
gala_test(
    name = "named_arg_sealed",
    srcs = [
        "named_arg_sealed_model.gala",
        "named_arg_sealed.gala",
    ],
    expected = "named_arg_sealed.out",
)

# FIX-016 verification: match with assignment-only branches (void match)
gala_test(
    name = "void_match",
    src = "void_match.gala",
    expected = "void_match.out",
    deps = [
        "//collection_immutable",
        "//go_interop",
    ],
)

# FIX-017 verification: *Future[Array[int]].Get() resolves to Array[int]
gala_test(
    name = "future_get_type_chain",
    src = "future_get_type_chain.gala",
    expected = "future_get_type_chain.out",
    deps = [
        "//concurrent",
        "//collection_immutable",
    ],
)

# Character literals and raw strings
gala_test(
    name = "char_and_raw_string",
    src = "char_and_raw_string.gala",
    expected = "char_and_raw_string.out",
)

# StringBuilder
gala_test(
    name = "string_builder",
    src = "string_builder.gala",
    expected = "string_builder.out",
    deps = ["//string_utils"],
)

# FIX-022 verification: block lambda return type in generic function calls
gala_test(
    name = "block_lambda_generic_func",
    src = "block_lambda_generic_func.gala",
    expected = "block_lambda_generic_func.out",
)
