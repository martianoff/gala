package collection_mutable

import (
    "fmt"
    . "martianoff/gala/std"
)

// TreeSet is a mutable sorted set implemented as a Red-Black tree.
// It maintains elements in sorted order and provides O(log n) operations.
//
// Elements must be either:
// - Primitive types (int, string, float64, etc.) - compared automatically
// - Types implementing the Ordered[T] interface
//
// Performance characteristics:
// - Add:      O(log n)
// - Remove:   O(log n)
// - Contains: O(log n)
// - Min/Max:  O(log n)
// - Size:     O(1) - cached
//
// Unlike Set, TreeSet maintains sorted order and supports range queries.

// Tree node colors for Red-Black tree
val mutableTreeRed int = 0
val mutableTreeBlack int = 1

// treeSetNode represents a node in the Red-Black tree.
type treeSetNode[T comparable] struct {
    var value  T
    var left   *treeSetNode[T]
    var right  *treeSetNode[T]
    var parent *treeSetNode[T]
    var color  int
}

// TreeSet represents a mutable sorted set.
type TreeSet[T comparable] struct {
    var root *treeSetNode[T]
    var size int
}

// EmptyTreeSet returns a new empty TreeSet.
func EmptyTreeSet[T comparable]() *TreeSet[T] {
    var nilRoot *treeSetNode[T] = nil
    return &TreeSet[T](root = nilRoot, size = 0)
}

// TreeSetOf creates a TreeSet from variadic arguments.
// Example: TreeSetOf[int](3, 1, 2) creates TreeSet(1, 2, 3)
func TreeSetOf[T comparable](elements ...T) *TreeSet[T] {
    var result = EmptyTreeSet[T]()
    for i := 0; i < len(elements); i++ {
        result.Add(elements[i])
    }
    return result
}

// TreeSetFromSlice creates a TreeSet from a slice.
func TreeSetFromSlice[T comparable](elements []T) *TreeSet[T] {
    var result = EmptyTreeSet[T]()
    for i := 0; i < len(elements); i++ {
        result.Add(elements[i])
    }
    return result
}

// === Basic Operations ===

// IsEmpty returns true if the set is empty.
func (s *TreeSet[T]) IsEmpty() bool = s.size == 0

// NonEmpty returns true if the set is not empty.
func (s *TreeSet[T]) NonEmpty() bool = s.size > 0

// Size returns the number of elements. O(1) - cached.
func (s *TreeSet[T]) Size() int = s.size

// Length is an alias for Size.
func (s *TreeSet[T]) Length() int = s.size

// === Comparison ===

// treeSetCompare compares two values and returns -1, 0, or 1.
func treeSetCompare[T comparable](a T, b T) int {
    val va any = a
    val vb any = b

    val result = va match {
        case ai: int => treeSetCompareIntsAny(ai, vb)
        case as: string => treeSetCompareStringsAny(as, vb)
        case ai64: int64 => treeSetCompareInt64sAny(ai64, vb)
        case ai32: int32 => treeSetCompareInt32sAny(ai32, vb)
        case af64: float64 => treeSetCompareFloat64sAny(af64, vb)
        case af32: float32 => treeSetCompareFloat32sAny(af32, vb)
        case au: uint => treeSetCompareUintsAny(au, vb)
        case au64: uint64 => treeSetCompareUint64sAny(au64, vb)
        case au32: uint32 => treeSetCompareUint32sAny(au32, vb)
        case ai16: int16 => treeSetCompareInt16sAny(ai16, vb)
        case ai8: int8 => treeSetCompareInt8sAny(ai8, vb)
        case au16: uint16 => treeSetCompareUint16sAny(au16, vb)
        case au8: uint8 => treeSetCompareUint8sAny(au8, vb)
        case ao: Ordered[T] => ao.Compare(b)
        case _ => treeSetPanicNotOrdered(va)
    }
    return result
}

// Type-specific comparison helpers
func treeSetCompareIntsAny(a int, vb any) int {
    val b = vb match { case bi: int => bi case _ => 0 }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareStringsAny(a string, vb any) int {
    val b = vb match { case bs: string => bs case _ => "" }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareInt64sAny(a int64, vb any) int {
    val b = vb match { case bi: int64 => bi case _ => int64(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareInt32sAny(a int32, vb any) int {
    val b = vb match { case bi: int32 => bi case _ => int32(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareInt16sAny(a int16, vb any) int {
    val b = vb match { case bi: int16 => bi case _ => int16(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareInt8sAny(a int8, vb any) int {
    val b = vb match { case bi: int8 => bi case _ => int8(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareFloat64sAny(a float64, vb any) int {
    val b = vb match { case bf: float64 => bf case _ => float64(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareFloat32sAny(a float32, vb any) int {
    val b = vb match { case bf: float32 => bf case _ => float32(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareUintsAny(a uint, vb any) int {
    val b = vb match { case bu: uint => bu case _ => uint(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareUint64sAny(a uint64, vb any) int {
    val b = vb match { case bu: uint64 => bu case _ => uint64(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareUint32sAny(a uint32, vb any) int {
    val b = vb match { case bu: uint32 => bu case _ => uint32(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareUint16sAny(a uint16, vb any) int {
    val b = vb match { case bu: uint16 => bu case _ => uint16(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetCompareUint8sAny(a uint8, vb any) int {
    val b = vb match { case bu: uint8 => bu case _ => uint8(0) }
    if a < b { return -1 }
    if a > b { return 1 }
    return 0
}

func treeSetPanicNotOrdered(v any) int {
    panic(fmt.Sprintf("TreeSet: type %T must implement std.Ordered interface", v))
}

// isRedTreeSetNode checks if a node is red (nil nodes are black).
func isRedTreeSetNode[T comparable](node *treeSetNode[T]) bool {
    if node == nil {
        return false
    }
    return node.color == mutableTreeRed
}

// === Query Operations ===

// Contains checks if the set contains the given element. O(log n).
func (s *TreeSet[T]) Contains(elem T) bool {
    var node = s.root
    for node != nil {
        val cmp = treeSetCompare[T](elem, node.value)
        if cmp < 0 {
            node = node.left
        } else if cmp > 0 {
            node = node.right
        } else {
            return true
        }
    }
    return false
}

// === Mutating Operations ===

// Add adds an element to the set. O(log n).
// Returns true if the element was added (not already present).
func (s *TreeSet[T]) Add(elem T) bool {
    if s.root == nil {
        s.root = &treeSetNode[T](value = elem, color = mutableTreeBlack)
        s.size = 1
        return true
    }

    // Find insertion point
    var parent *treeSetNode[T] = nil
    var node = s.root
    var cmp = 0
    for node != nil {
        parent = node
        cmp = treeSetCompare[T](elem, node.value)
        if cmp < 0 {
            node = node.left
        } else if cmp > 0 {
            node = node.right
        } else {
            return false // Already exists
        }
    }

    // Insert new node
    var newNode = &treeSetNode[T](value = elem, parent = parent, color = mutableTreeRed)
    if cmp < 0 {
        parent.left = newNode
    } else {
        parent.right = newNode
    }
    s.size++

    // Rebalance
    s.fixAfterInsert(newNode)
    return true
}

// fixAfterInsert rebalances the tree after insertion.
func (s *TreeSet[T]) fixAfterInsert(node *treeSetNode[T]) {
    for node != s.root && node.parent.color == mutableTreeRed {
        if node.parent == node.parent.parent.left {
            var uncle = node.parent.parent.right
            if isRedTreeSetNode[T](uncle) {
                // Case 1: Uncle is red
                node.parent.color = mutableTreeBlack
                uncle.color = mutableTreeBlack
                node.parent.parent.color = mutableTreeRed
                node = node.parent.parent
            } else {
                if node == node.parent.right {
                    // Case 2: Node is right child
                    node = node.parent
                    s.rotateLeft(node)
                }
                // Case 3: Node is left child
                node.parent.color = mutableTreeBlack
                node.parent.parent.color = mutableTreeRed
                s.rotateRight(node.parent.parent)
            }
        } else {
            var uncle = node.parent.parent.left
            if isRedTreeSetNode[T](uncle) {
                // Case 1: Uncle is red
                node.parent.color = mutableTreeBlack
                uncle.color = mutableTreeBlack
                node.parent.parent.color = mutableTreeRed
                node = node.parent.parent
            } else {
                if node == node.parent.left {
                    // Case 2: Node is left child
                    node = node.parent
                    s.rotateRight(node)
                }
                // Case 3: Node is right child
                node.parent.color = mutableTreeBlack
                node.parent.parent.color = mutableTreeRed
                s.rotateLeft(node.parent.parent)
            }
        }
    }
    s.root.color = mutableTreeBlack
}

// rotateLeft performs a left rotation.
func (s *TreeSet[T]) rotateLeft(x *treeSetNode[T]) {
    var y = x.right
    x.right = y.left
    if y.left != nil {
        y.left.parent = x
    }
    y.parent = x.parent
    if x.parent == nil {
        s.root = y
    } else if x == x.parent.left {
        x.parent.left = y
    } else {
        x.parent.right = y
    }
    y.left = x
    x.parent = y
}

// rotateRight performs a right rotation.
func (s *TreeSet[T]) rotateRight(x *treeSetNode[T]) {
    var y = x.left
    x.left = y.right
    if y.right != nil {
        y.right.parent = x
    }
    y.parent = x.parent
    if x.parent == nil {
        s.root = y
    } else if x == x.parent.right {
        x.parent.right = y
    } else {
        x.parent.left = y
    }
    y.right = x
    x.parent = y
}

// AddAll adds all elements from a slice.
func (s *TreeSet[T]) AddAll(elements []T) {
    for i := 0; i < len(elements); i++ {
        s.Add(elements[i])
    }
}

// AddFrom adds all elements from another TreeSet.
func (s *TreeSet[T]) AddFrom(other *TreeSet[T]) {
    other.ForEach((elem T) => {
        s.Add(elem)
        return nil
    })
}

// Remove removes an element from the set. O(log n).
// Returns true if the element was removed (was present).
func (s *TreeSet[T]) Remove(elem T) bool {
    var node = s.findNode(elem)
    if node == nil {
        return false
    }
    s.deleteNode(node)
    s.size--
    return true
}

// findNode finds the node containing the element.
func (s *TreeSet[T]) findNode(elem T) *treeSetNode[T] {
    var node = s.root
    for node != nil {
        val cmp = treeSetCompare[T](elem, node.value)
        if cmp < 0 {
            node = node.left
        } else if cmp > 0 {
            node = node.right
        } else {
            return node
        }
    }
    return nil
}

// deleteNode removes a node from the tree.
func (s *TreeSet[T]) deleteNode(node *treeSetNode[T]) {
    // If node has two children, replace with successor
    if node.left != nil && node.right != nil {
        var successor = s.minNode(node.right)
        node.value = successor.value
        node = successor
    }

    // Node has at most one child
    var child *treeSetNode[T]
    if node.left != nil {
        child = node.left
    } else {
        child = node.right
    }

    if child != nil {
        child.parent = node.parent
        if node.parent == nil {
            s.root = child
        } else if node == node.parent.left {
            node.parent.left = child
        } else {
            node.parent.right = child
        }

        if node.color == mutableTreeBlack {
            s.fixAfterDelete(child)
        }
    } else if node.parent == nil {
        s.root = nil
    } else {
        if node.color == mutableTreeBlack {
            s.fixAfterDelete(node)
        }

        if node.parent != nil {
            if node == node.parent.left {
                node.parent.left = nil
            } else {
                node.parent.right = nil
            }
        }
    }
}

// fixAfterDelete rebalances the tree after deletion.
func (s *TreeSet[T]) fixAfterDelete(node *treeSetNode[T]) {
    for node != s.root && (node == nil || node.color == mutableTreeBlack) {
        if node == nil {
            return
        }
        if node.parent == nil {
            return
        }
        if node == node.parent.left {
            var sibling = node.parent.right
            if sibling != nil && sibling.color == mutableTreeRed {
                sibling.color = mutableTreeBlack
                node.parent.color = mutableTreeRed
                s.rotateLeft(node.parent)
                sibling = node.parent.right
            }

            if sibling == nil {
                node = node.parent
            } else if (!isRedTreeSetNode[T](sibling.left)) && (!isRedTreeSetNode[T](sibling.right)) {
                sibling.color = mutableTreeRed
                node = node.parent
            } else {
                if !isRedTreeSetNode[T](sibling.right) {
                    if sibling.left != nil {
                        sibling.left.color = mutableTreeBlack
                    }
                    sibling.color = mutableTreeRed
                    s.rotateRight(sibling)
                    sibling = node.parent.right
                }
                if sibling != nil {
                    sibling.color = node.parent.color
                }
                node.parent.color = mutableTreeBlack
                if sibling != nil && sibling.right != nil {
                    sibling.right.color = mutableTreeBlack
                }
                s.rotateLeft(node.parent)
                node = s.root
            }
        } else {
            var sibling = node.parent.left
            if sibling != nil && sibling.color == mutableTreeRed {
                sibling.color = mutableTreeBlack
                node.parent.color = mutableTreeRed
                s.rotateRight(node.parent)
                sibling = node.parent.left
            }

            if sibling == nil {
                node = node.parent
            } else if (!isRedTreeSetNode[T](sibling.right)) && (!isRedTreeSetNode[T](sibling.left)) {
                sibling.color = mutableTreeRed
                node = node.parent
            } else {
                if !isRedTreeSetNode[T](sibling.left) {
                    if sibling.right != nil {
                        sibling.right.color = mutableTreeBlack
                    }
                    sibling.color = mutableTreeRed
                    s.rotateLeft(sibling)
                    sibling = node.parent.left
                }
                if sibling != nil {
                    sibling.color = node.parent.color
                }
                node.parent.color = mutableTreeBlack
                if sibling != nil && sibling.left != nil {
                    sibling.left.color = mutableTreeBlack
                }
                s.rotateRight(node.parent)
                node = s.root
            }
        }
    }
    if node != nil {
        node.color = mutableTreeBlack
    }
}

// RemoveAll removes all elements from a slice.
func (s *TreeSet[T]) RemoveAll(elements []T) {
    for i := 0; i < len(elements); i++ {
        s.Remove(elements[i])
    }
}

// Clear removes all elements. O(1).
func (s *TreeSet[T]) Clear() {
    s.root = nil
    s.size = 0
}

// === Min/Max Operations ===

// Min returns the minimum element in the set. O(log n).
// Panics if the set is empty.
func (s *TreeSet[T]) Min() T {
    if s.size == 0 {
        panic("TreeSet.Min on empty set")
    }
    return s.minNode(s.root).value
}

// minNode finds the node with minimum value in subtree.
func (s *TreeSet[T]) minNode(node *treeSetNode[T]) *treeSetNode[T] {
    for node.left != nil {
        node = node.left
    }
    return node
}

// MinOption returns the minimum element wrapped in Option. O(log n).
func (s *TreeSet[T]) MinOption() Option[T] {
    if s.size == 0 {
        return None[T]()
    }
    return Some[T](s.Min())
}

// Max returns the maximum element in the set. O(log n).
// Panics if the set is empty.
func (s *TreeSet[T]) Max() T {
    if s.size == 0 {
        panic("TreeSet.Max on empty set")
    }
    return s.maxNode(s.root).value
}

// maxNode finds the node with maximum value in subtree.
func (s *TreeSet[T]) maxNode(node *treeSetNode[T]) *treeSetNode[T] {
    for node.right != nil {
        node = node.right
    }
    return node
}

// MaxOption returns the maximum element wrapped in Option. O(log n).
func (s *TreeSet[T]) MaxOption() Option[T] {
    if s.size == 0 {
        return None[T]()
    }
    return Some[T](s.Max())
}

// PopMin removes and returns the minimum element. O(log n).
// Panics if the set is empty.
func (s *TreeSet[T]) PopMin() T {
    if s.size == 0 {
        panic("TreeSet.PopMin on empty set")
    }
    var minVal = s.Min()
    s.Remove(minVal)
    return minVal
}

// PopMax removes and returns the maximum element. O(log n).
// Panics if the set is empty.
func (s *TreeSet[T]) PopMax() T {
    if s.size == 0 {
        panic("TreeSet.PopMax on empty set")
    }
    var maxVal = s.Max()
    s.Remove(maxVal)
    return maxVal
}

// === Set Operations ===

// Union returns a new set containing all elements from both sets.
func (s *TreeSet[T]) Union(other *TreeSet[T]) *TreeSet[T] {
    var result = s.Clone()
    result.AddFrom(other)
    return result
}

// Intersect returns a new set containing only elements present in both sets.
func (s *TreeSet[T]) Intersect(other *TreeSet[T]) *TreeSet[T] {
    // Iterate over the smaller set for efficiency
    if s.Size() <= other.Size() {
        return s.FoldLeft[*TreeSet[T]](EmptyTreeSet[T](), (acc *TreeSet[T], elem T) => {
            if other.Contains(elem) {
                acc.Add(elem)
            }
            return acc
        })
    }
    return other.FoldLeft[*TreeSet[T]](EmptyTreeSet[T](), (acc *TreeSet[T], elem T) => {
        if s.Contains(elem) {
            acc.Add(elem)
        }
        return acc
    })
}

// Diff returns a new set containing elements in this set but not in other.
func (s *TreeSet[T]) Diff(other *TreeSet[T]) *TreeSet[T] {
    return s.FoldLeft[*TreeSet[T]](EmptyTreeSet[T](), (acc *TreeSet[T], elem T) => {
        if !other.Contains(elem) {
            acc.Add(elem)
        }
        return acc
    })
}

// SubsetOf returns true if this set is a subset of other.
func (s *TreeSet[T]) SubsetOf(other *TreeSet[T]) bool {
    if s.Size() > other.Size() {
        return false
    }
    return s.FoldLeft[bool](true, (acc bool, elem T) => acc && other.Contains(elem))
}

// SupersetOf returns true if this set is a superset of other.
func (s *TreeSet[T]) SupersetOf(other *TreeSet[T]) bool = other.SubsetOf(s)

// === In-place Set Operations ===

// UnionInPlace adds all elements from other to this set.
func (s *TreeSet[T]) UnionInPlace(other *TreeSet[T]) {
    s.AddFrom(other)
}

// IntersectInPlace removes elements not in other.
func (s *TreeSet[T]) IntersectInPlace(other *TreeSet[T]) {
    var toRemove []T
    s.ForEach((elem T) => {
        if !other.Contains(elem) {
            toRemove = append(toRemove, elem)
        }
        return nil
    })
    s.RemoveAll(toRemove)
}

// DiffInPlace removes elements that are in other.
func (s *TreeSet[T]) DiffInPlace(other *TreeSet[T]) {
    var toRemove []T
    s.ForEach((elem T) => {
        if other.Contains(elem) {
            toRemove = append(toRemove, elem)
        }
        return nil
    })
    s.RemoveAll(toRemove)
}

// === Range Operations ===

// Range returns elements in the range [from, to] inclusive as a new TreeSet.
func (s *TreeSet[T]) Range(from T, to T) *TreeSet[T] {
    var result = EmptyTreeSet[T]()
    s.rangeInOrder(s.root, from, to, (elem T) => {
        result.Add(elem)
        return nil
    })
    return result
}

// rangeInOrder traverses nodes within the range in order.
func (s *TreeSet[T]) rangeInOrder(node *treeSetNode[T], from T, to T, f func(T) any) {
    if node == nil {
        return
    }
    val cmpFrom = treeSetCompare[T](node.value, from)
    val cmpTo = treeSetCompare[T](node.value, to)

    if cmpFrom > 0 {
        s.rangeInOrder(node.left, from, to, f)
    }
    if cmpFrom >= 0 && cmpTo <= 0 {
        f(node.value)
    }
    if cmpTo < 0 {
        s.rangeInOrder(node.right, from, to, f)
    }
}

// RangeFrom returns all elements >= from.
func (s *TreeSet[T]) RangeFrom(from T) *TreeSet[T] {
    var result = EmptyTreeSet[T]()
    s.rangeFromInOrder(s.root, from, (elem T) => {
        result.Add(elem)
        return nil
    })
    return result
}

// rangeFromInOrder traverses nodes >= from in order.
func (s *TreeSet[T]) rangeFromInOrder(node *treeSetNode[T], from T, f func(T) any) {
    if node == nil {
        return
    }
    val cmp = treeSetCompare[T](node.value, from)
    if cmp > 0 {
        s.rangeFromInOrder(node.left, from, f)
    }
    if cmp >= 0 {
        f(node.value)
    }
    s.rangeFromInOrder(node.right, from, f)
}

// RangeTo returns all elements <= to.
func (s *TreeSet[T]) RangeTo(to T) *TreeSet[T] {
    var result = EmptyTreeSet[T]()
    s.rangeToInOrder(s.root, to, (elem T) => {
        result.Add(elem)
        return nil
    })
    return result
}

// rangeToInOrder traverses nodes <= to in order.
func (s *TreeSet[T]) rangeToInOrder(node *treeSetNode[T], to T, f func(T) any) {
    if node == nil {
        return
    }
    val cmp = treeSetCompare[T](node.value, to)
    s.rangeToInOrder(node.left, to, f)
    if cmp <= 0 {
        f(node.value)
    }
    if cmp < 0 {
        s.rangeToInOrder(node.right, to, f)
    }
}

// === Iteration ===

// ForEach applies a function to each element in sorted order.
func (s *TreeSet[T]) ForEach(f func(T) any) {
    s.inOrder(s.root, f)
}

// inOrder traverses the tree in sorted order.
func (s *TreeSet[T]) inOrder(node *treeSetNode[T], f func(T) any) {
    if node == nil {
        return
    }
    s.inOrder(node.left, f)
    f(node.value)
    s.inOrder(node.right, f)
}

// ForEachReverse applies a function to each element in reverse sorted order.
func (s *TreeSet[T]) ForEachReverse(f func(T) any) {
    s.reverseOrder(s.root, f)
}

// reverseOrder traverses the tree in reverse sorted order.
func (s *TreeSet[T]) reverseOrder(node *treeSetNode[T], f func(T) any) {
    if node == nil {
        return
    }
    s.reverseOrder(node.right, f)
    f(node.value)
    s.reverseOrder(node.left, f)
}

// === Transformation ===

// Filter returns a new TreeSet with only elements that satisfy the predicate.
func (s *TreeSet[T]) Filter(p func(T) bool) *TreeSet[T] {
    return s.FoldLeft[*TreeSet[T]](EmptyTreeSet[T](), (acc *TreeSet[T], elem T) => {
        if p(elem) {
            acc.Add(elem)
        }
        return acc
    })
}

// FilterNot returns a new TreeSet with elements that do not satisfy the predicate.
func (s *TreeSet[T]) FilterNot(p func(T) bool) *TreeSet[T] = s.Filter((elem T) => !p(elem))

// Collect applies a partial function to each element and collects the results.
// Elements for which the function returns None are filtered out.
// Returns a mutable Array since the result type may not be comparable.
func (s *TreeSet[T]) Collect[U any](pf func(T) Option[U]) *Array[U] {
    var result = EmptyArray[U]()
    s.ForEach((elem T) => {
        var opt = pf(elem)
        if opt.IsDefined() {
            result.Append(opt.Get())
        }
        return nil
    })
    return result
}

// Partition splits the set into two sets based on a predicate.
func (s *TreeSet[T]) Partition(p func(T) bool) Tuple[*TreeSet[T], *TreeSet[T]] {
    var left = s.Filter(p)
    var right = s.FilterNot(p)
    return Tuple[*TreeSet[T], *TreeSet[T]](V1 = left, V2 = right)
}

// Map applies a function to each element and returns a new set.
func (s *TreeSet[T]) Map[U comparable](f func(T) U) *TreeSet[U] {
    return s.FoldLeft[*TreeSet[U]](EmptyTreeSet[U](), (acc *TreeSet[U], elem T) => {
        acc.Add(f(elem))
        return acc
    })
}

// FlatMap applies a function that returns a set to each element and flattens.
func (s *TreeSet[T]) FlatMap[U comparable](f func(T) *TreeSet[U]) *TreeSet[U] {
    return s.FoldLeft[*TreeSet[U]](EmptyTreeSet[U](), (acc *TreeSet[U], elem T) => {
        acc.AddFrom(f(elem))
        return acc
    })
}

// === Reduction Operations ===

// FoldLeft applies a binary operator from left to right (in sorted order).
func (s *TreeSet[T]) FoldLeft[U any](initial U, f func(U, T) U) U {
    var acc = initial
    s.ForEach((elem T) => {
        acc = f(acc, elem)
        return nil
    })
    return acc
}

// Reduce applies a binary operator, starting with the first element.
// Panics if the set is empty.
func (s *TreeSet[T]) Reduce(f func(T, T) T) T {
    if s.size == 0 {
        panic("TreeSet.Reduce on empty set")
    }
    var first = true
    var acc T
    s.ForEach((elem T) => {
        if first {
            acc = elem
            first = false
        } else {
            acc = f(acc, elem)
        }
        return nil
    })
    return acc
}

// ReduceOption is like Reduce but returns None for empty set.
func (s *TreeSet[T]) ReduceOption(f func(T, T) T) Option[T] {
    if s.size == 0 {
        return None[T]()
    }
    return Some[T](s.Reduce(f))
}

// === Predicate Operations ===

// Exists returns true if any element satisfies the predicate.
func (s *TreeSet[T]) Exists(p func(T) bool) bool {
    return s.FoldLeft[bool](false, (acc bool, elem T) => acc || p(elem))
}

// ForAll returns true if all elements satisfy the predicate.
func (s *TreeSet[T]) ForAll(p func(T) bool) bool {
    return s.FoldLeft[bool](true, (acc bool, elem T) => acc && p(elem))
}

// Find returns the first element (in sorted order) that satisfies the predicate.
func (s *TreeSet[T]) Find(p func(T) bool) Option[T] {
    return s.FoldLeft[Option[T]](None[T](), (acc Option[T], elem T) => {
        if acc.IsEmpty() && p(elem) {
            return Some[T](elem)
        }
        return acc
    })
}

// Count returns the number of elements satisfying the predicate.
func (s *TreeSet[T]) Count(p func(T) bool) int {
    return s.FoldLeft[int](0, (acc int, elem T) => {
        if p(elem) {
            return acc + 1
        }
        return acc
    })
}

// === Element Access ===

// Head returns the minimum element (alias for Min).
// Panics if the set is empty.
func (s *TreeSet[T]) Head() T = s.Min()

// HeadOption returns the minimum element wrapped in Option.
func (s *TreeSet[T]) HeadOption() Option[T] = s.MinOption()

// Last returns the maximum element (alias for Max).
// Panics if the set is empty.
func (s *TreeSet[T]) Last() T = s.Max()

// LastOption returns the maximum element wrapped in Option.
func (s *TreeSet[T]) LastOption() Option[T] = s.MaxOption()

// === Conversion ===

// ToGoSlice converts the set to a Go slice in sorted order.
func (s *TreeSet[T]) ToGoSlice() []T {
    var result []T
    s.ForEach((elem T) => {
        result = append(result, elem)
        return nil
    })
    return result
}

// ToArray converts the set to a mutable Array (in sorted order).
func (s *TreeSet[T]) ToArray() *Array[T] {
    var result = ArrayWithCapacity[T](s.Size())
    s.ForEach((elem T) => {
        result.Append(elem)
        return nil
    })
    return result
}

// ToList converts the set to a mutable List (in sorted order).
func (s *TreeSet[T]) ToList() *List[T] {
    // Traverse in reverse order so prepending gives sorted order
    var result = EmptyList[T]()
    s.ForEachReverse((elem T) => {
        result.Prepend(elem)
        return nil
    })
    return result
}

// ToHashSet converts the set to a mutable HashSet (loses ordering but gains O(1) lookup).
func (s *TreeSet[T]) ToHashSet() *HashSet[T] {
    var result = EmptyHashSet[T]()
    s.ForEach((elem T) => {
        result.Add(elem)
        return nil
    })
    return result
}

// Clone creates a shallow copy of the set.
func (s *TreeSet[T]) Clone() *TreeSet[T] {
    var result = EmptyTreeSet[T]()
    s.ForEach((elem T) => {
        result.Add(elem)
        return nil
    })
    return result
}

// String returns a string representation of the set in sorted order.
func (s *TreeSet[T]) String() string {
    if s.size == 0 {
        return "TreeSet()"
    }
    var result = "TreeSet("
    var first = true
    s.ForEach((elem T) => {
        if !first {
            result = result + ", "
        }
        result = result + fmt.Sprintf("%v", elem)
        first = false
        return nil
    })
    return result + ")"
}
