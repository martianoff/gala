package main

import (
    . "martianoff/gala/test"
    . "martianoff/gala/std"
)

// Option tests
func TestOptionSome(t T) T {
    val opt = Some(42)
    var t1 = IsFalse(t, opt.IsEmpty())
    var t2 = Eq[int](t1, opt.Get(), 42)
    return Eq[int](t2, opt.GetOrElse(0), 42)
}

func TestOptionNone(t T) T {
    val opt Option[int] = None[int]()
    var t1 = IsTrue(t, opt.IsEmpty())
    return Eq[int](t1, opt.GetOrElse(42), 42)
}

func TestOptionMap(t T) T {
    val opt = Some(21)
    val mapped Option[int] = opt.Map((x int) => x * 2)
    var t1 = Eq[int](t, mapped.Get(), 42)

    val none Option[int] = None[int]()
    val noneMapped Option[int] = none.Map((x int) => x * 2)
    return IsTrue(t1, noneMapped.IsEmpty())
}

func TestOptionFlatMap(t T) T {
    val opt = Some(21)
    val flatMapped Option[int] = opt.FlatMap((x int) => Some(x * 2))
    var t1 = Eq[int](t, flatMapped.Get(), 42)

    val none Option[int] = None[int]()
    val noneFlatMapped Option[int] = none.FlatMap((x int) => Some(x * 2))
    return IsTrue(t1, noneFlatMapped.IsEmpty())
}

func TestOptionFilter(t T) T {
    val opt = Some(42)
    val filtered Option[int] = opt.Filter((x int) => x > 40)
    var t1 = Eq[int](t, filtered.Get(), 42)

    val filteredNone Option[int] = opt.Filter((x int) => x < 40)
    return IsTrue(t1, filteredNone.IsEmpty())
}

func TestOptionPatternMatching(t T) T {
    val some = Some(42)
    val vAny = some match {
        case Some(x: int) => x
        case _ => -1
    }
    var t1 = t
    if vAny != 42 {
        t1 = t.Error("Match failed for Some")
    }

    val none Option[int] = None[int]()
    val isNoneAny = none match {
        case None() => true
        case _ => false
    }
    if isNoneAny != true {
        return t1.Error("Match failed for None")
    }
    return t1
}

// Either tests
func TestEitherLeft(t T) T {
    val e Either[int, string] = Left[int, string](42)
    val isLeft = e match {
        case Left(_) => true
        case _ => false
    }
    var t1 = t
    if isLeft != true {
        t1 = t.Error("Should be Left")
    }
    return Eq[int](t1, e.GetLeft(), 42)
}

func TestEitherRight(t T) T {
    val e Either[int, string] = Right[int, string]("hello")
    val isRight = e match {
        case Right(_) => true
        case _ => false
    }
    var t1 = t
    if isRight != true {
        t1 = t.Error("Should be Right")
    }
    return Eq[string](t1, e.GetRight(), "hello")
}

func TestEitherSwap(t T) T {
    val e Either[int, string] = Left[int, string](42)
    val swapped Either[string, int] = e.Swap()
    val isRight = swapped match {
        case Right(_) => true
        case _ => false
    }
    var t1 = t
    if isRight != true {
        t1 = t.Error("Should be Right after swap")
    }
    return Eq[int](t1, swapped.GetRight(), 42)
}

func TestEitherFold(t T) T {
    val l Either[int, string] = Left[int, string](42)
    val fl any = l.Fold[int]((x int) => x, (s string) => 0)
    var t1 = t
    if fl != 42 {
        t1 = t.Error("Fold failed for Left")
    }

    val r Either[int, string] = Right[int, string]("hello")
    val fr any = r.Fold[int]((x int) => 0, (s string) => 1)
    if fr != 1 {
        return t1.Error("Fold failed for Right")
    }
    return t1
}

func TestEitherMap(t T) T {
    val r Either[int, int] = Right[int, int](21)
    val mapped Either[int, int] = r.Map((x int) => x * 2)
    var t1 = Eq[int](t, mapped.GetRight(), 42)

    val l Either[int, int] = Left[int, int](21)
    val mappedL Either[int, int] = l.Map((x int) => x * 2)
    val isLeft = mappedL match {
        case Left(_) => true
        case _ => false
    }
    if isLeft != true {
        t1 = t1.Error("Should remain Left after Map")
    }
    return Eq[int](t1, mappedL.GetLeft(), 21)
}

func TestEitherFlatMap(t T) T {
    val r Either[int, int] = Right[int, int](21)
    val flatMapped Either[int, int] = r.FlatMap((x int) => Right[int, int](x * 2))
    var t1 = Eq[int](t, flatMapped.GetRight(), 42)

    val l Either[int, int] = Left[int, int](21)
    val flatMappedL Either[int, int] = l.FlatMap((x int) => Right[int, int](x * 2))
    val isLeft = flatMappedL match {
        case Left(_) => true
        case _ => false
    }
    if isLeft != true {
        return t1.Error("Should remain Left after FlatMap")
    }
    return t1
}

func TestEitherPatternMatching(t T) T {
    val l Either[int, string] = Left[int, string](42)
    val isLeft42 = l match {
        case Left(x: int) if x == 42 => true
        case _ => false
    }
    var t1 = t
    if isLeft42 != true {
        t1 = t.Error("Pattern match failed for Left")
    }

    val r Either[int, string] = Right[int, string]("hello")
    val isRightHello = r match {
        case Right(x: string) if x == "hello" => true
        case _ => false
    }
    if isRightHello != true {
        return t1.Error("Pattern match failed for Right")
    }
    return t1
}
