package std

// isDefined returns true if the value is defined.
// It handles Option types by checking defined field, bool types by their value,
// nil as false, and all other types as true.
func isDefined(opt any) bool = if (opt == nil) false else opt match {
    case b: bool => b
    case oi: Option[_] => oi.defined
    case _ => true
}

// getSomeValue returns the option's value if it is an Option, otherwise returns the value itself.
func getSomeValue(opt any) any = opt match {
    case oi: Option[_] => oi.Value
    case _ => opt
}

// Option represents an optional value: every instance of Option is either an instance
// of Some containing a value, or None representing an empty value.
type Option[T any] struct {
    Value T
    defined bool
}

type Some struct {}
func (s Some) Apply[T any](v T) Option[T] = Option[T](Value = v, defined = true)
func (s Some) Unapply(o any) any = if (isDefined(o)) getSomeValue(o) else nil

type None struct {}
func (n None) Apply[T any]() Option[T] = Option[T](defined = false)
func (n None) Unapply(o any) bool = !isDefined(o)

// isDefined returns true if the option is an instance of Some, false otherwise.
func (o Option[T]) isDefined() bool = o.defined

// getValue returns the option's value as any.
func (o Option[T]) getValue() any = o.Value

// IsEmpty returns true if the option is None, false otherwise.
func (o Option[T]) IsEmpty() bool = !o.defined

// Get returns the option's value if the option is Some, otherwise it panics.
func (o Option[T]) Get() T {
    if !o.defined {
        panic("Option.Get on None")
    }
    return o.Value
}

// GetOrElse returns the option's value if the option is Some, otherwise returns the result of evaluating defaultValue.
// defaultValue: the default value to return if the option is empty.
func (o Option[T]) GetOrElse(defaultValue T) T {
    if o.defined {
        return o.Value
    }
    return defaultValue
}

// ForEach applies the given procedure f to the option's value, if it is nonempty.
// f: the procedure to apply.
func (o Option[T]) ForEach(f func(T) any) {
    if o.defined {
        f(o.Value)
    }
}

// Map builds a new option by applying a function to all values of this option.
// f: the function to apply.
// Returns a new Option containing the result of applying f to this option's value if it is nonempty.
func (o Option[T]) Map[U any](f func(T) U) Option[U] {
    if o.defined {
        return Some[U](f(o.Value))
    }
    return None[U]()
}

// FlatMap returns the result of applying f to this option's value if this option is nonempty.
// Returns None if this option is empty.
// f: the function to apply.
func (o Option[T]) FlatMap[U any](f func(T) Option[U]) Option[U] {
    if o.defined {
        return f(o.Value)
    }
    return None[U]()
}

// Filter returns this option if it is nonempty and applying the predicate p to this option's value returns true.
// p: the predicate used for testing.
func (o Option[T]) Filter(p func(T) bool) Option[T] {
    if o.defined && p(o.Value) {
        return o
    }
    return None[T]()
}
