package std

// Try represents a computation that may either result in a value of type T (Success)
// or a failure with an error (Failure). It provides a functional approach to error
// handling, similar to Scala's Try monad.
//
// Every instance of Try is either:
// - Success[T]: contains a successful value of type T
// - Failure[T]: contains an error
type Try[T any] struct {
    Value     T
    Err       error
    isSuccess bool
}

// Success is a companion object for creating successful Try instances.
type Success[T any] struct {}

// Apply creates a Success Try with the given value.
func (s Success[T]) Apply(v T) Try[T] = Try[T](Value = v, isSuccess = true)

// Unapply extracts the value from a Success for pattern matching.
func (s Success[T]) Unapply(t Try[T]) Option[T] {
    if t.IsSuccess() {
        return Some[T](t.Value)
    }
    return None[T]()
}

// Failure is a companion object for creating failed Try instances.
type Failure[T any] struct {}

// Apply creates a Failure Try with the given error.
func (f Failure[T]) Apply(err error) Try[T] = Try[T](Err = err, isSuccess = false)

// Unapply extracts the error from a Failure for pattern matching.
func (f Failure[T]) Unapply(t Try[T]) Option[error] {
    if t.IsFailure() {
        return Some[error](t.Err)
    }
    return None[error]()
}

// Internal accessor methods for pattern matching
func (t Try[T]) getIsSuccess() bool = t.isSuccess
func (t Try[T]) getValue() any = t.Value
func (t Try[T]) getErr() any = t.Err

// IsSuccess returns true if this is a Success, false otherwise.
func (t Try[T]) IsSuccess() bool = t.isSuccess

// IsFailure returns true if this is a Failure, false otherwise.
func (t Try[T]) IsFailure() bool = !t.isSuccess

// Get returns the value if this is a Success, otherwise panics.
func (t Try[T]) Get() T {
    if !t.isSuccess {
        panic("Try.Get on Failure: " + t.Err.Error())
    }
    return t.Value
}

// GetError returns the error if this is a Failure, otherwise panics.
func (t Try[T]) GetError() error {
    if t.isSuccess {
        panic("Try.GetError on Success")
    }
    return t.Err
}

// GetOrElse returns the value if this is a Success, otherwise returns defaultValue.
func (t Try[T]) GetOrElse(defaultValue T) T {
    if t.isSuccess {
        return t.Value
    }
    return defaultValue
}

// OrElse returns this Try if it is a Success, otherwise returns alternative.
func (t Try[T]) OrElse(alternative Try[T]) Try[T] {
    if t.isSuccess {
        return t
    }
    return alternative
}

// ForEach applies the given procedure f to the value if this is a Success.
func (t Try[T]) ForEach(f func(T) any) {
    if t.isSuccess {
        f(t.Value)
    }
}

// Map applies the function f to the value if this is a Success.
// Returns a new Try containing the result. If f panics, the result is a Failure.
func (t Try[T]) Map[U any](f func(T) U) Try[U] {
    if !t.isSuccess {
        return Failure[U](t.Err)
    }
    return Success[U](f(t.Value))
}

// FlatMap applies the function f to the value if this is a Success.
// Returns the Try returned by f. If this is a Failure, returns the Failure.
func (t Try[T]) FlatMap[U any](f func(T) Try[U]) Try[U] {
    if !t.isSuccess {
        return Failure[U](t.Err)
    }
    return f(t.Value)
}

// Filter returns this Try if this is a Success and the predicate p returns true.
// Returns a Failure with NoSuchElementError if predicate returns false.
func (t Try[T]) Filter(p func(T) bool) Try[T] {
    if !t.isSuccess {
        return t
    }
    if p(t.Value) {
        return t
    }
    return Failure[T](NoSuchElementError(Message = "Predicate does not hold"))
}

// Recover applies the recovery function pf to the error if this is a Failure.
// Returns a Success with the recovered value. If pf panics, the result is still a Failure.
func (t Try[T]) Recover(pf func(error) T) Try[T] {
    if t.isSuccess {
        return t
    }
    return Success[T](pf(t.Err))
}

// RecoverWith applies the recovery function pf to the error if this is a Failure.
// Returns the Try returned by pf. If this is a Success, returns this Try.
func (t Try[T]) RecoverWith(pf func(error) Try[T]) Try[T] {
    if t.isSuccess {
        return t
    }
    return pf(t.Err)
}

// Transform applies s if this is a Success, f if this is a Failure.
// Both functions return a new Try.
func (t Try[T]) Transform[U any](s func(T) Try[U], f func(error) Try[U]) Try[U] {
    if t.isSuccess {
        return s(t.Value)
    }
    return f(t.Err)
}

// Fold applies fa if this is a Failure, fs if this is a Success.
func (t Try[T]) Fold[U any](fa func(error) U, fs func(T) U) U {
    if t.isSuccess {
        return fs(t.Value)
    }
    return fa(t.Err)
}

// ToOption returns Some(value) if this is a Success, None if this is a Failure.
func (t Try[T]) ToOption() Option[T] {
    if t.isSuccess {
        return Some[T](t.Value)
    }
    return None[T]()
}

// ToEither returns Right(value) if this is a Success, Left(error) if this is a Failure.
func (t Try[T]) ToEither() Either[error, T] {
    if t.isSuccess {
        return Right[error, T](t.Value)
    }
    return Left[error, T](t.Err)
}

// FromOption creates a Try from an Option.
// Returns Success if the Option is Some, Failure with NoSuchElementError if None.
func FromOption[T any](o Option[T]) Try[T] {
    if o.IsDefined() {
        return Success[T](o.Get())
    }
    return Failure[T](NoSuchElementError(Message = "Option is None"))
}

// FromEitherError creates a Try from an Either[error, T].
// Returns Success if Right, Failure if Left.
func FromEitherError[T any](e Either[error, T]) Try[T] {
    if e.IsRight() {
        return Success[T](e.GetRight())
    }
    return Failure[T](e.GetLeft())
}
