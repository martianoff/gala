package std

type EitherInterface interface {
    getIsLeft() bool
    isRight() bool
    getLeftValue() any
    getRightValue() any
}

// Either represents a value of one of two possible types (a disjoint union).
// An instance of Either is an instance of either Left or Right.
type Either[A any, B any] struct {
    LeftValue A
    RightValue B
    isLeft bool
}

func (e Either[A, B]) getIsLeft() bool = e.isLeft
func (e Either[A, B]) getLeftValue() any = e.LeftValue
func (e Either[A, B]) getRightValue() any = e.RightValue

type Left struct {}
func (l Left) Apply[A any, B any](v A) Either[A, B] = Either[A, B](LeftValue = v, isLeft = true)
func (l Left) Unapply(e any) any = if (isLeft(e)) Some(getLeftValue(e)) else None[any]()

type Right struct {}
func (r Right) Apply[A any, B any](v B) Either[A, B] = Either[A, B](RightValue = v, isLeft = false)
func (r Right) Unapply(e any) any = if (isRight(e)) Some(getRightValue(e)) else None[any]()

// isLeft returns true if this is a Left, false otherwise.
func isLeft(e any) bool = e match {
    case ei: EitherInterface => ei.getIsLeft()
    case _ => false
}

// isRight returns true if this is a Right, false otherwise.
func isRight(e any) bool = e match {
    case ei: EitherInterface => ei.isRight()
    case _ => false
}

// getLeftValue returns the left value if this is a Left, otherwise it returns nil.
func getLeftValue(e any) any = e match {
    case ei: EitherInterface => ei.getLeftValue()
    case _ => nil
}

// getRightValue returns the right value if this is a Right, otherwise it returns nil.
func getRightValue(e any) any = e match {
    case ei: EitherInterface => ei.getRightValue()
    case _ => nil
}

// isRight returns true if this is a Right, false otherwise.
func (e Either[A, B]) isRight() bool = !e.isLeft

// GetLeft returns the left value if this is a Left, otherwise it panics.
func (e Either[A, B]) GetLeft() A {
    if !e.isLeft {
        panic("Either.GetLeft on Right")
    }
    return e.LeftValue
}

// GetRight returns the right value if this is a Right, otherwise it panics.
func (e Either[A, B]) GetRight() B {
    if e.isLeft {
        panic("Either.GetRight on Left")
    }
    return e.RightValue
}

// Swap returns the left as right and vice versa.
func (e Either[A, B]) Swap() Either[B, A] {
    if e.isLeft {
        return Right[B, A](e.LeftValue)
    }
    return Left[B, A](e.RightValue)
}

// Fold applies f1 to the left value or f2 to the right value.
func (e Either[A, B]) Fold[C any](f1 func(A) C, f2 func(B) C) C {
    if e.isLeft {
        return f1(e.LeftValue)
    }
    return f2(e.RightValue)
}

// Map applies a function to the right value if this is a Right.
func (e Either[A, B]) Map[C any](f func(B) C) Either[A, C] {
    if e.isLeft {
        return Left[A, C](e.LeftValue)
    }
    return Right[A, C](f(e.RightValue))
}

// FlatMap applies a function to the right value if this is a Right.
func (e Either[A, B]) FlatMap[C any](f func(B) Either[A, C]) Either[A, C] {
    if e.isLeft {
        return Left[A, C](e.LeftValue)
    }
    return f(e.RightValue)
}
