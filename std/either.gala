package std

type EitherInterface interface {
    GetIsLeft() bool
    IsRight() bool
    GetLeftValue() any
    GetRightValue() any
}

// Either represents a value of one of two possible types (a disjoint union).
// An instance of Either is an instance of either Left or Right.
type Either[A any, B any] struct {
    LeftValue A
    RightValue B
    IsLeft bool
}

func (e Either[A, B]) GetIsLeft() bool = e.IsLeft
func (e Either[A, B]) GetLeftValue() any = e.LeftValue
func (e Either[A, B]) GetRightValue() any = e.RightValue

type Left struct {}
func (l Left) Apply[A any, B any](v A) Either[A, B] = Either[A, B](LeftValue = v, IsLeft = true)
func (l Left) Unapply(e any) any = if (IsLeft(e)) Some(GetLeftValue(e)) else None[any]()

type Right struct {}
func (r Right) Apply[A any, B any](v B) Either[A, B] = Either[A, B](RightValue = v, IsLeft = false)
func (r Right) Unapply(e any) any = if (IsRight(e)) Some(GetRightValue(e)) else None[any]()

// IsLeft returns true if this is a Left, false otherwise.
func IsLeft(e any) bool = e match {
    case ei: EitherInterface => ei.GetIsLeft()
    case _ => false
}

// IsRight returns true if this is a Right, false otherwise.
func IsRight(e any) bool = e match {
    case ei: EitherInterface => ei.IsRight()
    case _ => false
}

// GetLeftValue returns the left value if this is a Left, otherwise it returns nil.
func GetLeftValue(e any) any = e match {
    case ei: EitherInterface => ei.GetLeftValue()
    case _ => nil
}

// GetRightValue returns the right value if this is a Right, otherwise it returns nil.
func GetRightValue(e any) any = e match {
    case ei: EitherInterface => ei.GetRightValue()
    case _ => nil
}

// IsRight returns true if this is a Right, false otherwise.
func (e Either[A, B]) IsRight() bool = !e.IsLeft

// GetLeft returns the left value if this is a Left, otherwise it panics.
func (e Either[A, B]) GetLeft() A {
    if !e.IsLeft {
        panic("Either.GetLeft on Right")
    }
    return e.LeftValue
}

// GetRight returns the right value if this is a Right, otherwise it panics.
func (e Either[A, B]) GetRight() B {
    if e.IsLeft {
        panic("Either.GetRight on Left")
    }
    return e.RightValue
}

// Swap returns the left as right and vice versa.
func (e Either[A, B]) Swap() Either[B, A] {
    if e.IsLeft {
        return Right[B, A](e.LeftValue)
    }
    return Left[B, A](e.RightValue)
}

// Fold applies f1 to the left value or f2 to the right value.
func (e Either[A, B]) Fold[C any](f1 func(A) C, f2 func(B) C) C {
    if e.IsLeft {
        return f1(e.LeftValue)
    }
    return f2(e.RightValue)
}

// Map applies a function to the right value if this is a Right.
func (e Either[A, B]) Map[C any](f func(B) C) Either[A, C] {
    if e.IsLeft {
        return Left[A, C](e.LeftValue)
    }
    return Right[A, C](f(e.RightValue))
}

// FlatMap applies a function to the right value if this is a Right.
func (e Either[A, B]) FlatMap[C any](f func(B) Either[A, C]) Either[A, C] {
    if e.IsLeft {
        return Left[A, C](e.LeftValue)
    }
    return f(e.RightValue)
}
