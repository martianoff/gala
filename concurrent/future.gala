package concurrent

import (
    "time"
    . "martianoff/gala/std"
    "martianoff/gala/go_interop"
    . "martianoff/gala/collection_immutable"
)

// Future represents an asynchronous computation that will eventually produce
// a value of type T or fail with an error. It provides a functional approach
// to concurrent programming, similar to Scala's Future monad.
//
// A Future is immutable once created - its eventual result cannot be changed.
// To create completable futures, use Promise[T].
//
// Each Future has an associated ExecutionContext that determines where callbacks
// and derived futures execute. By default, futures use GlobalEC(). Use the
// *With variants (FutureApplyWith, FutureOfWith, etc.) to specify a custom EC.
type Future[T any] struct {
    var result   Try[T]
    var done     go_interop.Signal
    var once     *go_interop.Once
    var mu       *go_interop.RWMutex
    var complete bool
    var ec       go_interop.ExecutionContext
}

// Promise is a writable, single-assignment container that completes a Future.
// A Promise can be completed exactly once, either with a success value or a failure.
type Promise[T any] struct {
    var future *Future[T]
}

// NewPromise creates a new Promise and its associated Future using GlobalEC().
func NewPromise[T any]() *Promise[T] {
    return NewPromiseWith[T](go_interop.GlobalEC())
}

// NewPromiseWith creates a new Promise and its associated Future with a custom ExecutionContext.
func NewPromiseWith[T any](ec go_interop.ExecutionContext) *Promise[T] {
    val f = &Future[T](
        done = go_interop.NewSignal(),
        once = go_interop.NewOnce(),
        mu = go_interop.NewRWMutex(),
        complete = false,
        ec = ec
    )
    return &Promise[T](future = f)
}

// Future returns the Future associated with this Promise.
func (p *Promise[T]) Future() *Future[T] = p.future

// Success completes the Promise with a successful value.
// Returns true if the Promise was completed, false if already completed.
func (p *Promise[T]) Success(value T) bool {
    return p.Complete(Success[T](value))
}

// Failure completes the Promise with an error.
// Returns true if the Promise was completed, false if already completed.
func (p *Promise[T]) Failure(err error) bool {
    return p.Complete(Failure[T](err))
}

// Complete completes the Promise with a Try result.
// Returns true if the Promise was completed, false if already completed.
func (p *Promise[T]) Complete(result Try[T]) bool {
    return p.future.once.Do(() => {
        p.future.mu.Lock()
        p.future.result = result
        p.future.complete = true
        p.future.mu.Unlock()
        go_interop.CloseSignal(p.future.done)
    })
}

// IsCompleted returns true if the Promise has been completed.
func (p *Promise[T]) IsCompleted() bool {
    p.future.mu.RLock()
    val c = p.future.complete
    p.future.mu.RUnlock()
    return c
}

// FutureOf creates an already successfully completed Future with the given value using GlobalEC().
func FutureOf[T any](value T) *Future[T] {
    return FutureOfWith[T](value, go_interop.GlobalEC())
}

// FutureOfWith creates an already successfully completed Future with a custom ExecutionContext.
func FutureOfWith[T any](value T, ec go_interop.ExecutionContext) *Future[T] {
    val p = NewPromiseWith[T](ec)
    p.Success(value)
    return p.Future()
}

// FutureFailed creates an already failed Future with the given error using GlobalEC().
func FutureFailed[T any](err error) *Future[T] {
    return FutureFailedWith[T](err, go_interop.GlobalEC())
}

// FutureFailedWith creates an already failed Future with a custom ExecutionContext.
func FutureFailedWith[T any](err error, ec go_interop.ExecutionContext) *Future[T] {
    val p = NewPromiseWith[T](ec)
    p.Failure(err)
    return p.Future()
}

// FutureApply creates a Future that will execute the given function asynchronously using GlobalEC().
// If the function panics, the Future will be completed with a Failure.
func FutureApply[T any](f func() T) *Future[T] {
    return FutureApplyWith[T](f, go_interop.GlobalEC())
}

// FutureApplyWith creates a Future that will execute the given function asynchronously
// using the specified ExecutionContext. If the function panics, the Future will be
// completed with a Failure.
func FutureApplyWith[T any](f func() T, ec go_interop.ExecutionContext) *Future[T] {
    val p = NewPromiseWith[T](ec)
    val onSuccess = () => { p.Success(f()) }
    val onPanic = (r any) => {
        p.Failure(go_interop.PanicToError(r))
    }
    ec.ExecuteWithRecover(onSuccess, onPanic)
    return p.Future()
}

// FutureError is a custom error type for Future-related errors.
struct FutureError(Message string)

func (e FutureError) Error() string = e.Message

// IsCompleted returns true if the Future has been completed (success or failure).
func (f *Future[T]) IsCompleted() bool {
    f.mu.RLock()
    val c = f.complete
    f.mu.RUnlock()
    return c
}

// Value returns the current result as an Option[Try[T]].
// Returns None if the Future is not yet completed.
func (f *Future[T]) Value() Option[Try[T]] {
    f.mu.RLock()
    val c = f.complete
    val r = f.result
    f.mu.RUnlock()
    if c {
        return Some[Try[T]](r)
    }
    return None[Try[T]]()
}

// Await blocks until the Future is completed and returns the result.
func (f *Future[T]) Await() Try[T] {
    go_interop.WaitSignal(f.done)
    f.mu.RLock()
    val r = f.result
    f.mu.RUnlock()
    return r
}

// AwaitFor blocks until the Future is completed or the timeout expires.
// Returns None if the timeout expires before the Future completes.
func (f *Future[T]) AwaitFor(timeout time.Duration) Option[Try[T]] {
    val received = go_interop.WaitSignalTimeout(f.done, timeout)
    if received {
        f.mu.RLock()
        val r = f.result
        f.mu.RUnlock()
        return Some[Try[T]](r)
    }
    return None[Try[T]]()
}

// Get blocks until the Future is completed and returns the value.
// Panics if the Future completed with a failure.
func (f *Future[T]) Get() T = f.Await().Get()

// GetOrElse blocks until the Future is completed and returns the value,
// or the default value if the Future completed with a failure.
func (f *Future[T]) GetOrElse(defaultValue T) T = f.Await().GetOrElse(defaultValue)

// ExecutionContext returns the ExecutionContext associated with this Future.
func (f *Future[T]) ExecutionContext() go_interop.ExecutionContext = f.ec

// OnComplete registers a callback to be executed when the Future completes.
// The callback is executed asynchronously using this Future's ExecutionContext.
// Note: callback returns any for GALA lambda compatibility.
func (f *Future[T]) OnComplete(callback func(Try[T]) any) {
    f.ec.Execute(() => {
        go_interop.WaitSignal(f.done)
        f.mu.RLock()
        val r = f.result
        f.mu.RUnlock()
        callback(r)
    })
}

// OnSuccess registers a callback to be executed if the Future completes successfully.
// The callback is executed asynchronously.
// Note: callback returns any for GALA lambda compatibility.
func (f *Future[T]) OnSuccess(callback func(T) any) {
    f.OnComplete((r Try[T]) => {
        if r.IsSuccess() {
            callback(r.Value)
        }
    })
}

// OnFailure registers a callback to be executed if the Future completes with a failure.
// The callback is executed asynchronously.
// Note: callback returns any for GALA lambda compatibility.
func (f *Future[T]) OnFailure(callback func(error) any) {
    f.OnComplete((r Try[T]) => {
        if r.IsFailure() {
            callback(r.Err)
        }
    })
}

// Map transforms the successful value of this Future using the given function.
// If this Future fails, the resulting Future will also fail with the same error.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) Map[U any](fn func(T) U) *Future[U] {
    val p = NewPromiseWith[U](f.ec)
    f.OnComplete((r Try[T]) => {
        p.Complete(r.Map[U](fn))
    })
    return p.Future()
}

// FlatMap transforms the successful value of this Future using a function
// that returns another Future. This allows chaining asynchronous operations.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) FlatMap[U any](fn func(T) *Future[U]) *Future[U] {
    val p = NewPromiseWith[U](f.ec)
    f.OnComplete((r Try[T]) => {
        if r.IsSuccess() {
            fn(r.Value).OnComplete((innerResult Try[U]) => {
                p.Complete(innerResult)
            })
        } else {
            p.Failure(r.Err)
        }
    })
    return p.Future()
}

// Filter returns a new Future that contains the value only if it satisfies
// the predicate. If the predicate returns false, the Future fails with
// NoSuchElementError.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) Filter(predicate func(T) bool) *Future[T] {
    val p = NewPromiseWith[T](f.ec)
    f.OnComplete((r Try[T]) => {
        p.Complete(r.Filter(predicate))
    })
    return p.Future()
}

// Recover handles failures by applying a recovery function.
// If this Future fails, the recovery function is applied to the error
// to produce a successful value.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) Recover(pf func(error) T) *Future[T] {
    val p = NewPromiseWith[T](f.ec)
    f.OnComplete((r Try[T]) => {
        p.Complete(r.Recover(pf))
    })
    return p.Future()
}

// RecoverWith handles failures by applying a recovery function
// that returns another Future.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) RecoverWith(pf func(error) *Future[T]) *Future[T] {
    val p = NewPromiseWith[T](f.ec)
    f.OnComplete((r Try[T]) => {
        if r.IsSuccess() {
            p.Success(r.Value)
        } else {
            pf(r.Err).OnComplete((recovered Try[T]) => {
                p.Complete(recovered)
            })
        }
    })
    return p.Future()
}

// Transform applies success or failure function based on the result.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) Transform[U any](s func(T) Try[U], fn func(error) Try[U]) *Future[U] {
    val p = NewPromiseWith[U](f.ec)
    f.OnComplete((r Try[T]) => {
        if r.IsSuccess() {
            p.Complete(s(r.Value))
        } else {
            p.Complete(fn(r.Err))
        }
    })
    return p.Future()
}

// TransformWith applies success or failure function that returns a Future.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) TransformWith[U any](s func(T) *Future[U], fn func(error) *Future[U]) *Future[U] {
    val p = NewPromiseWith[U](f.ec)
    f.OnComplete((r Try[T]) => {
        if r.IsSuccess() {
            s(r.Value).OnComplete((res Try[U]) => {
                p.Complete(res)
            })
        } else {
            fn(r.Err).OnComplete((res Try[U]) => {
                p.Complete(res)
            })
        }
    })
    return p.Future()
}

// Zip combines two Futures into a Future of a tuple.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) Zip[U any](other *Future[U]) *Future[Tuple[T, U]] {
    return f.FlatMap[Tuple[T, U]]((t T) => {
        return other.Map[Tuple[T, U]]((u U) => Tuple[T, U](V1 = t, V2 = u))
    })
}

// ZipWith combines two Futures using a combining function.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) ZipWith[U any, V any](other *Future[U], fn func(T, U) V) *Future[V] {
    return f.FlatMap[V]((t T) => {
        return other.Map[V]((u U) => fn(t, u))
    })
}

// Fallback returns the first successful Future, or the last failure if both fail.
// The resulting Future inherits this Future's ExecutionContext.
func (f *Future[T]) Fallback(that *Future[T]) *Future[T] {
    return f.RecoverWith((e error) => that)
}

// AndThen registers a callback and returns a new Future that completes
// with the same result after the callback executes.
// The resulting Future inherits this Future's ExecutionContext.
// Note: callback returns any for GALA lambda compatibility.
func (f *Future[T]) AndThen(callback func(Try[T]) any) *Future[T] {
    val p = NewPromiseWith[T](f.ec)
    f.OnComplete((r Try[T]) => {
        callback(r)
        p.Complete(r)
    })
    return p.Future()
}

// ToTry converts the Future to a Try by blocking until completion.
func (f *Future[T]) ToTry() Try[T] = f.Await()

// ToOption converts the successful value to an Option by blocking.
// Returns None if the Future fails.
func (f *Future[T]) ToOption() Option[T] = f.Await().ToOption()

// ToEither converts the Future result to an Either by blocking.
func (f *Future[T]) ToEither() Either[error, T] = f.Await().ToEither()

// Sequence converts an Array of Futures into a Future of an Array.
// If any Future fails, the resulting Future fails with that error.
func Sequence[T any](futures Array[*Future[T]]) *Future[Array[T]] {
    if futures.IsEmpty() {
        return FutureOf[Array[T]](EmptyArray[T]())
    }

    val p = NewPromise[Array[T]]()
    val size = futures.Size()
    val mu = go_interop.NewMutex()
    var remaining = size
    var failed = false

    // We need to collect results in order, so use a map to store results by index
    var resultMap = EmptyHashMap[int, T]()

    // Iterate with index using ZipWithIndex
    futures.ZipWithIndex().ForEach((pair Tuple[*Future[T], int]) => {
        val fut = pair.V1
        val idx = pair.V2
        fut.OnComplete((r Try[T]) => {
            mu.Lock()

            if !failed {
                if r.IsSuccess() {
                    resultMap = resultMap.Put(idx, r.Value)
                    remaining = remaining - 1
                    if remaining == 0 {
                        // Build the result array in order
                        var result = EmptyArray[T]()
                        for i := 0; i < size; i++ {
                            result = result.Append(resultMap.GetOrElse(i, r.Value))
                        }
                        p.Success(result)
                    }
                } else {
                    failed = true
                    p.Failure(r.Err)
                }
            }

            mu.Unlock()
        })
    })

    return p.Future()
}

// FirstCompletedOf returns a Future that completes with the result of
// the first Future to complete from the given collection.
func FirstCompletedOf[T any](futures Array[*Future[T]]) *Future[T] {
    val p = NewPromise[T]()

    futures.ForEach((fut *Future[T]) => {
        fut.OnComplete((r Try[T]) => {
            p.Complete(r)
        })
    })

    return p.Future()
}

// Traverse applies a function that returns a Future to each element
// and sequences the results.
func Traverse[T any, U any](items Array[T], fn func(T) *Future[U]) *Future[Array[U]] {
    val futures = items.Map[*Future[U]]((item T) => fn(item))
    return Sequence[U](futures)
}

// Fold reduces a collection of Futures into a single Future.
func Fold[T any, U any](futures Array[*Future[T]], zero U, op func(U, T) U) *Future[U] {
    return Sequence[T](futures).Map[U]((results Array[T]) => {
        return results.FoldLeft[U](zero, op)
    })
}

// ReduceLeft reduces a non-empty collection of Futures to a single Future.
func ReduceLeft[T any](futures Array[*Future[T]], op func(T, T) T) *Future[T] {
    if futures.IsEmpty() {
        return FutureFailed[T](FutureError(Message = "Cannot reduce empty collection"))
    }
    if futures.Size() == 1 {
        return futures.Get(0)
    }

    return Sequence[T](futures).Map[T]((results Array[T]) => {
        return results.Tail().FoldLeft[T](results.Head(), op)
    })
}

// === Pattern Matching Support ===

// Completed is an extractor for pattern matching on completed Futures.
// It awaits the Future and extracts the Try result.
//
// Usage:
//   future match {
//       case Completed(Success(v)) => fmt.Sprintf("Got: %v", v)
//       case Completed(Failure(e)) => fmt.Sprintf("Error: %s", e.Error())
//       case _ => "Unknown"
//   }
type Completed[T any] struct {}

// Unapply awaits the Future and extracts its Try result for pattern matching.
func (c Completed[T]) Unapply(f *Future[T]) Option[Try[T]] {
    if f == nil {
        return None[Try[T]]()
    }
    return Some[Try[T]](f.Await())
}

// Succeeded is an extractor for pattern matching on successful Futures.
// It awaits the Future and extracts the value if successful.
//
// Usage:
//   future match {
//       case Succeeded(v) => fmt.Sprintf("Got: %v", v)
//       case Failed(e) => fmt.Sprintf("Error: %s", e.Error())
//       case _ => "Unknown"
//   }
type Succeeded[T any] struct {}

// Unapply awaits the Future and extracts its value if successful.
func (s Succeeded[T]) Unapply(f *Future[T]) Option[T] {
    if f == nil {
        return None[T]()
    }
    val result = f.Await()
    if result.IsSuccess() {
        return Some[T](result.Value)
    }
    return None[T]()
}

// Failed is an extractor for pattern matching on failed Futures.
// It awaits the Future and extracts the error if failed.
//
// Usage:
//   future match {
//       case Succeeded(v) => fmt.Sprintf("Got: %v", v)
//       case Failed(e) => fmt.Sprintf("Error: %s", e.Error())
//       case _ => "Unknown"
//   }
type Failed[T any] struct {}

// Unapply awaits the Future and extracts its error if failed.
func (fa Failed[T]) Unapply(f *Future[T]) Option[error] {
    if f == nil {
        return None[error]()
    }
    val result = f.Await()
    if result.IsFailure() {
        return Some[error](result.Err)
    }
    return None[error]()
}

// === Sequence Pattern Matching Support ===

// AllSucceeded is an extractor for matching when all Futures in a sequence succeed.
// It sequences the Futures and extracts the Array of values if all succeed.
//
// Usage:
//   futures match {
//       case AllSucceeded(values) => fmt.Sprintf("All succeeded: %v", values)
//       case AnyFailed(e) => fmt.Sprintf("One failed: %s", e.Error())
//       case _ => "Unknown"
//   }
type AllSucceeded[T any] struct {}

// Unapply sequences the Futures and extracts all values if all succeed.
func (a AllSucceeded[T]) Unapply(futures Array[*Future[T]]) Option[Array[T]] {
    val result = Sequence[T](futures).Await()
    if result.IsSuccess() {
        return Some[Array[T]](result.Value)
    }
    return None[Array[T]]()
}

// AnyFailed is an extractor for matching when any Future in a sequence fails.
// It returns the first error encountered.
//
// Usage:
//   futures match {
//       case AllSucceeded(values) => fmt.Sprintf("All succeeded: %v", values)
//       case AnyFailed(e) => fmt.Sprintf("One failed: %s", e.Error())
//       case _ => "Unknown"
//   }
type AnyFailed[T any] struct {}

// Unapply returns the first error if any Future in the sequence fails.
func (a AnyFailed[T]) Unapply(futures Array[*Future[T]]) Option[error] {
    val result = Sequence[T](futures).Await()
    if result.IsFailure() {
        return Some[error](result.Err)
    }
    return None[error]()
}
