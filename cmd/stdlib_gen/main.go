// stdlib_gen generates embedded stdlib Go code from transpiled sources.
// It reads Go source files and generates a Go file with the content as string maps.
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

var outputFile = flag.String("output", "", "Output file path")

// packageFromPath extracts the package name from a file path.
// e.g., "bazel-out/.../std/option.go" -> "std"
// or "std/types.go" -> "std"
func packageFromPath(path string) string {
	// Known packages in order of specificity
	packages := []string{
		"collection_immutable",
		"collection_mutable",
		"go_interop",
		"concurrent",
		"std",
	}

	for _, pkg := range packages {
		if strings.Contains(path, "/"+pkg+"/") || strings.Contains(path, "\\"+pkg+"\\") {
			return pkg
		}
		// Handle cases like "//std:types.go" or paths ending with package name
		if strings.HasPrefix(filepath.Base(filepath.Dir(path)), pkg) {
			return pkg
		}
	}

	// Fallback: use parent directory name
	return filepath.Base(filepath.Dir(path))
}

func main() {
	flag.Parse()

	if *outputFile == "" {
		fmt.Fprintln(os.Stderr, "Error: -output flag is required")
		os.Exit(1)
	}

	files := flag.Args()
	if len(files) == 0 {
		fmt.Fprintln(os.Stderr, "Error: no input files")
		os.Exit(1)
	}

	// Group files by package
	packageFiles := make(map[string]map[string]string) // pkg -> filename -> content

	for _, file := range files {
		content, err := os.ReadFile(file)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error reading %s: %v\n", file, err)
			os.Exit(1)
		}

		pkg := packageFromPath(file)
		filename := filepath.Base(file)

		// Normalize filename (remove _go suffix from Bazel target names)
		// and rename transpiled files to .gen.go convention
		if strings.HasSuffix(filename, "_go") {
			// Transpiled file: option_go -> option.gen.go
			filename = strings.TrimSuffix(filename, "_go") + ".gen.go"
		} else if strings.HasSuffix(filename, ".go") && !strings.HasSuffix(filename, ".gen.go") {
			// Check if this is a transpiled file (has corresponding .gala source)
			// For now, keep non-transpiled Go files (like types.go, interfaces.go) as-is
			// Transpiled files come through the _go suffix path above
		}

		if packageFiles[pkg] == nil {
			packageFiles[pkg] = make(map[string]string)
		}
		packageFiles[pkg][filename] = string(content)
	}

	// Generate output
	var out strings.Builder
	out.WriteString(`// Code generated by stdlib_gen. DO NOT EDIT.
package stdlib

// EmbeddedPackages contains all stdlib package files.
// Map structure: package name -> filename -> content
var EmbeddedPackages = map[string]map[string]string{
`)

	// Sort packages for deterministic output
	var pkgNames []string
	for pkg := range packageFiles {
		pkgNames = append(pkgNames, pkg)
	}
	sort.Strings(pkgNames)

	for _, pkg := range pkgNames {
		files := packageFiles[pkg]
		out.WriteString(fmt.Sprintf("\t%q: {\n", pkg))

		// Sort filenames for deterministic output
		var fileNames []string
		for name := range files {
			fileNames = append(fileNames, name)
		}
		sort.Strings(fileNames)

		for _, name := range fileNames {
			content := files[name]
			out.WriteString(fmt.Sprintf("\t\t%q: %q,\n", name, content))
		}
		out.WriteString("\t},\n")
	}

	out.WriteString("}\n\n")

	// Add package metadata
	out.WriteString(`// PackageImportPaths maps package names to their import paths.
var PackageImportPaths = map[string]string{
	"std":                  "martianoff/gala/std",
	"go_interop":           "martianoff/gala/go_interop",
	"collection_immutable": "martianoff/gala/collection_immutable",
	"collection_mutable":   "martianoff/gala/collection_mutable",
	"concurrent":           "martianoff/gala/concurrent",
}
`)

	if err := os.WriteFile(*outputFile, []byte(out.String()), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output: %v\n", err)
		os.Exit(1)
	}
}
