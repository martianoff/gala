package build

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"martianoff/gala/internal/depman/mod"
)

// GoModGenerator generates go.mod files for build workspaces.
type GoModGenerator struct {
	config *Config
}

// NewGoModGenerator creates a new go.mod generator.
func NewGoModGenerator(config *Config) *GoModGenerator {
	return &GoModGenerator{config: config}
}

// StdlibPackages lists all GALA stdlib packages.
var StdlibPackages = []string{
	"std",
	"go_interop",
	"collection_immutable",
	"collection_mutable",
	"concurrent",
	"stream",
	"string_utils",
}

// StdlibImportPaths maps package names to their import paths.
var StdlibImportPaths = map[string]string{
	"std":                  "martianoff/gala/std",
	"go_interop":           "martianoff/gala/go_interop",
	"collection_immutable": "martianoff/gala/collection_immutable",
	"collection_mutable":   "martianoff/gala/collection_mutable",
	"concurrent":           "martianoff/gala/concurrent",
	"stream":               "martianoff/gala/stream",
	"string_utils":         "martianoff/gala/string_utils",
}

// GenerateGoMod generates a go.mod file content for the workspace.
// It uses absolute paths to the global caches, avoiding symlinks.
func (g *GoModGenerator) GenerateGoMod(galaMod *mod.File, stdlibVersion string) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by GALA build system. DO NOT EDIT.\n")
	sb.WriteString("module gala-build-workspace\n\n")
	sb.WriteString("go 1.21\n\n")

	// Collect all requires
	var stdlibReqs []string
	var galaReqs []mod.Require
	var goReqs []mod.Require

	// Add stdlib requires
	for _, pkg := range StdlibPackages {
		importPath := StdlibImportPaths[pkg]
		stdlibReqs = append(stdlibReqs, importPath)
	}

	// Separate GALA and Go dependencies
	if galaMod != nil {
		for _, req := range galaMod.Require {
			if req.Go {
				goReqs = append(goReqs, req)
			} else {
				galaReqs = append(galaReqs, req)
			}
		}
	}

	// Collect transitive Go dependencies from GALA packages
	transitiveGoDeps := g.collectTransitiveGoDeps(galaReqs)
	for path, version := range transitiveGoDeps {
		// Don't duplicate if already in goReqs
		found := false
		for _, req := range goReqs {
			if req.Path == path {
				found = true
				break
			}
		}
		if !found {
			goReqs = append(goReqs, mod.Require{Path: path, Version: version})
		}
	}

	// Write require block
	sb.WriteString("require (\n")

	// Stdlib requires
	for _, importPath := range stdlibReqs {
		sb.WriteString(fmt.Sprintf("\t%s v0.0.0\n", importPath))
	}

	// GALA package requires
	for _, req := range galaReqs {
		sb.WriteString(fmt.Sprintf("\t%s %s\n", req.Path, req.Version))
	}

	// Go package requires (including transitive)
	for _, req := range goReqs {
		sb.WriteString(fmt.Sprintf("\t%s %s\n", req.Path, req.Version))
	}

	sb.WriteString(")\n\n")

	// Write replace directives with absolute paths
	sb.WriteString("// Replace directives using absolute paths to global cache\n")

	// Stdlib replaces
	stdlibDir := g.config.StdlibVersionDir(stdlibVersion)
	for _, pkg := range StdlibPackages {
		importPath := StdlibImportPaths[pkg]
		absPath := filepath.Join(stdlibDir, pkg)
		// Convert to forward slashes for go.mod compatibility
		absPath = filepath.ToSlash(absPath)
		sb.WriteString(fmt.Sprintf("replace %s => %s\n", importPath, absPath))
	}

	sb.WriteString("\n")

	// GALA package replaces
	for _, req := range galaReqs {
		absPath := g.config.GalaModulePath(req.Path, req.Version)
		// Convert to forward slashes for go.mod compatibility
		absPath = filepath.ToSlash(absPath)
		sb.WriteString(fmt.Sprintf("replace %s => %s\n", req.Path, absPath))
	}

	// Go packages don't need replace directives - they're fetched via GOMODCACHE

	return sb.String()
}

// collectTransitiveGoDeps scans GALA packages for their Go dependencies.
func (g *GoModGenerator) collectTransitiveGoDeps(galaReqs []mod.Require) map[string]string {
	deps := make(map[string]string)

	for _, req := range galaReqs {
		// Read the GALA package's go.mod or gala.mod
		pkgDir := g.config.GalaModulePath(req.Path, req.Version)

		// Try gala.mod first
		galaModPath := filepath.Join(pkgDir, "gala.mod")
		if galaMod, err := mod.ParseFile(galaModPath); err == nil {
			for _, r := range galaMod.Require {
				if r.Go {
					deps[r.Path] = r.Version
				}
			}
		}

		// Also try go.mod for Go dependencies
		goModPath := filepath.Join(pkgDir, "go.mod")
		if content, err := os.ReadFile(goModPath); err == nil {
			// Parse go.mod for require statements
			goDeps := parseGoModRequires(string(content))
			for path, version := range goDeps {
				// Skip GALA stdlib
				if strings.HasPrefix(path, "martianoff/gala/") {
					continue
				}
				deps[path] = version
			}
		}
	}

	return deps
}

// parseGoModRequires extracts require statements from go.mod content.
func parseGoModRequires(content string) map[string]string {
	deps := make(map[string]string)
	lines := strings.Split(content, "\n")
	inRequireBlock := false

	for _, line := range lines {
		line = strings.TrimSpace(line)

		if line == "require (" {
			inRequireBlock = true
			continue
		}
		if inRequireBlock && line == ")" {
			inRequireBlock = false
			continue
		}

		// Single-line require
		if strings.HasPrefix(line, "require ") && !strings.Contains(line, "(") {
			parts := strings.Fields(line[8:])
			if len(parts) >= 2 {
				deps[parts[0]] = parts[1]
			}
			continue
		}

		// Inside require block
		if inRequireBlock {
			// Remove comments
			if idx := strings.Index(line, "//"); idx >= 0 {
				line = strings.TrimSpace(line[:idx])
			}
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				deps[parts[0]] = parts[1]
			}
		}
	}

	return deps
}

// WriteGoMod writes the go.mod file to the workspace.
func (g *GoModGenerator) WriteGoMod(workspace *Workspace, galaMod *mod.File, stdlibVersion string) error {
	content := g.GenerateGoMod(galaMod, stdlibVersion)
	return os.WriteFile(workspace.GoModPath, []byte(content), 0644)
}

// GenerateGoSum generates a minimal go.sum file.
// For now, this is empty as we use replace directives for GALA deps.
func (g *GoModGenerator) GenerateGoSum(galaMod *mod.File) string {
	// Go dependencies will have their checksums added by `go mod tidy`
	// GALA dependencies use replace directives so don't need checksums
	return ""
}

// WriteGoSum writes the go.sum file to the workspace.
func (g *GoModGenerator) WriteGoSum(workspace *Workspace, galaMod *mod.File) error {
	content := g.GenerateGoSum(galaMod)
	return os.WriteFile(workspace.GoSumPath, []byte(content), 0644)
}

// CollectImports scans generated Go files and returns all import paths.
func CollectImports(genDir string) ([]string, error) {
	entries, err := os.ReadDir(genDir)
	if err != nil {
		return nil, err
	}

	imports := make(map[string]bool)

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".go") {
			continue
		}

		content, err := os.ReadFile(filepath.Join(genDir, entry.Name()))
		if err != nil {
			continue
		}

		// Simple import extraction
		extractImports(string(content), imports)
	}

	var result []string
	for imp := range imports {
		result = append(result, imp)
	}
	sort.Strings(result)

	return result, nil
}

// extractImports extracts import paths from Go source code.
func extractImports(content string, imports map[string]bool) {
	lines := strings.Split(content, "\n")
	inImportBlock := false

	for _, line := range lines {
		line = strings.TrimSpace(line)

		if line == "import (" {
			inImportBlock = true
			continue
		}
		if inImportBlock && line == ")" {
			inImportBlock = false
			continue
		}

		// Single import
		if strings.HasPrefix(line, "import ") && !strings.Contains(line, "(") {
			if start := strings.Index(line, "\""); start >= 0 {
				if end := strings.LastIndex(line, "\""); end > start {
					imports[line[start+1:end]] = true
				}
			}
			continue
		}

		// Import block entry
		if inImportBlock {
			// Handle aliased imports: alias "path"
			if start := strings.Index(line, "\""); start >= 0 {
				if end := strings.LastIndex(line, "\""); end > start {
					imports[line[start+1:end]] = true
				}
			}
		}
	}
}

// IsStdlibImport returns true if the import path is a GALA stdlib package.
func IsStdlibImport(importPath string) bool {
	for _, stdlibImport := range StdlibImportPaths {
		if importPath == stdlibImport {
			return true
		}
	}
	return false
}

// IsGoStdlibImport returns true if the import path is a Go standard library package.
func IsGoStdlibImport(importPath string) bool {
	// Go stdlib packages don't contain dots in their path
	return !strings.Contains(importPath, ".")
}
