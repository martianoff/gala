// Package stdlib provides embedded GALA standard library packages.
// These packages can be extracted for standalone Go builds.
package stdlib

import (
	"os"
	"path/filepath"
)

// Package represents a stdlib package.
type Package struct {
	Name       string // Package name (e.g., "std")
	ImportPath string // Full import path (e.g., "martianoff/gala/std")
}

// Packages returns all stdlib packages.
func Packages() []Package {
	var pkgs []Package
	for name, importPath := range PackageImportPaths {
		pkgs = append(pkgs, Package{Name: name, ImportPath: importPath})
	}
	return pkgs
}

// ExtractTo extracts all embedded stdlib packages to the given directory.
// The directory structure will be:
//
//	destDir/
//	  std/
//	    go.mod
//	    option.go
//	    ...
//	  go_interop/
//	    go.mod
//	    types.go
//	  collection_immutable/
//	    ...
//	  collection_mutable/
//	    ...
//	  concurrent/
//	    ...
func ExtractTo(destDir string) error {
	for pkgName, files := range EmbeddedPackages {
		pkgDir := filepath.Join(destDir, pkgName)
		if err := os.MkdirAll(pkgDir, 0755); err != nil {
			return err
		}

		// Write Go source files
		for filename, content := range files {
			filePath := filepath.Join(pkgDir, filename)
			if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
				return err
			}
		}

		// Create go.mod for this package
		importPath := PackageImportPaths[pkgName]
		goModContent := generatePackageGoMod(pkgName, importPath)
		goModPath := filepath.Join(pkgDir, "go.mod")
		if err := os.WriteFile(goModPath, []byte(goModContent), 0644); err != nil {
			return err
		}
	}
	return nil
}

// generatePackageGoMod generates a go.mod file for a stdlib package.
func generatePackageGoMod(pkgName, importPath string) string {
	content := "// Code generated by GALA transpiler. DO NOT EDIT.\n"
	content += "module " + importPath + "\n\ngo 1.21\n"

	// Add dependencies based on package
	switch pkgName {
	case "std":
		// std has no dependencies
	case "go_interop":
		// go_interop has no GALA dependencies
	case "collection_immutable":
		content += "\nrequire (\n"
		content += "\tmartianoff/gala/std v0.0.0\n"
		content += "\tmartianoff/gala/go_interop v0.0.0\n"
		content += ")\n"
		content += "\nreplace martianoff/gala/std => ../std\n"
		content += "replace martianoff/gala/go_interop => ../go_interop\n"
	case "collection_mutable":
		content += "\nrequire (\n"
		content += "\tmartianoff/gala/std v0.0.0\n"
		content += "\tmartianoff/gala/go_interop v0.0.0\n"
		content += ")\n"
		content += "\nreplace martianoff/gala/std => ../std\n"
		content += "replace martianoff/gala/go_interop => ../go_interop\n"
	case "concurrent":
		content += "\nrequire (\n"
		content += "\tmartianoff/gala/std v0.0.0\n"
		content += "\tmartianoff/gala/go_interop v0.0.0\n"
		content += "\tmartianoff/gala/collection_immutable v0.0.0\n"
		content += ")\n"
		content += "\nreplace martianoff/gala/std => ../std\n"
		content += "\nreplace martianoff/gala/go_interop => ../go_interop\n"
		content += "replace martianoff/gala/collection_immutable => ../collection_immutable\n"
	case "stream":
		content += "\nrequire (\n"
		content += "\tmartianoff/gala/std v0.0.0\n"
		content += "\tmartianoff/gala/go_interop v0.0.0\n"
		content += "\tmartianoff/gala/collection_immutable v0.0.0\n"
		content += ")\n"
		content += "\nreplace martianoff/gala/std => ../std\n"
		content += "replace martianoff/gala/go_interop => ../go_interop\n"
		content += "replace martianoff/gala/collection_immutable => ../collection_immutable\n"
	case "string_utils":
		content += "\nrequire (\n"
		content += "\tmartianoff/gala/std v0.0.0\n"
		content += "\tmartianoff/gala/collection_immutable v0.0.0\n"
		content += ")\n"
		content += "\nreplace martianoff/gala/std => ../std\n"
		content += "replace martianoff/gala/collection_immutable => ../collection_immutable\n"
	}

	return content
}

// ExtractPackage extracts a single package to the destination directory.
func ExtractPackage(pkgName, destDir string) error {
	files, ok := EmbeddedPackages[pkgName]
	if !ok {
		return nil
	}

	pkgDir := filepath.Join(destDir, pkgName)
	if err := os.MkdirAll(pkgDir, 0755); err != nil {
		return err
	}

	for filename, content := range files {
		filePath := filepath.Join(pkgDir, filename)
		if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
			return err
		}
	}
	return nil
}

// GetPackageFiles returns the list of Go files in a package.
func GetPackageFiles(pkgName string) []string {
	files, ok := EmbeddedPackages[pkgName]
	if !ok {
		return nil
	}

	var names []string
	for name := range files {
		names = append(names, name)
	}
	return names
}

// GetPackageContent returns the content of a specific file in a package.
func GetPackageContent(pkgName, fileName string) (string, bool) {
	files, ok := EmbeddedPackages[pkgName]
	if !ok {
		return "", false
	}

	content, ok := files[fileName]
	return content, ok
}

// GenerateGoMod generates a go.mod file content with replace directives
// for all stdlib packages, pointing to the given base directory.
func GenerateGoMod(modulePath, goVersion, baseDir string) string {
	content := "module " + modulePath + "\n\ngo " + goVersion + "\n\n"

	for pkgName, importPath := range PackageImportPaths {
		localPath := "./" + baseDir + "/" + pkgName
		content += "replace " + importPath + " => " + localPath + "\n"
	}

	return content
}

// GenerateGoModReplace generates just the replace directives for an existing go.mod.
func GenerateGoModReplace(baseDir string) string {
	var content string
	for pkgName, importPath := range PackageImportPaths {
		localPath := "./" + baseDir + "/" + pkgName
		content += "replace " + importPath + " => " + localPath + "\n"
	}
	return content
}
