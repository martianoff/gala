package main

import (
    "fmt"
    . "martianoff/gala/test"
    . "martianoff/gala/collection_immutable"
    . "martianoff/gala/std"
    "martianoff/gala/go_interop"
)

// === Basic Operations Tests ===

func TestTreeMapEmpty(t T) T {
    val m = EmptyTreeMap[string, int]()
    var t1 = IsTrue(t, m.IsEmpty())
    var t2 = IsFalse(t1, m.NonEmpty())
    return Eq[int](t2, m.Size(), 0)
}

func TestTreeMapPut(t T) T {
    val m = EmptyTreeMap[string, int]()
    val m1 = m.Put("c", 3)
    val m2 = m1.Put("a", 1)
    val m3 = m2.Put("b", 2)

    var t1 = Eq[int](t, m.Size(), 0)
    var t2 = Eq[int](t1, m1.Size(), 1)
    var t3 = Eq[int](t2, m2.Size(), 2)
    return Eq[int](t3, m3.Size(), 3)
}

func TestTreeMapPutUpdate(t T) T {
    val m = EmptyTreeMap[string, int]()
    val m1 = m.Put("a", 1)
    val m2 = m1.Put("a", 2)

    var t1 = Eq[int](t, m2.Size(), 1)
    return Eq[int](t1, m2.GetOrElse("a", 0), 2)
}

func TestTreeMapOf(t T) T {
    val m = TreeMapOf[string, int](
        Tuple[string, int](V1 = "a", V2 = 1),
        Tuple[string, int](V1 = "b", V2 = 2),
        Tuple[string, int](V1 = "c", V2 = 3)
    )
    var t1 = Eq[int](t, m.Size(), 3)
    var t2 = IsTrue(t1, m.Contains("a"))
    var t3 = IsTrue(t2, m.Contains("b"))
    return IsTrue(t3, m.Contains("c"))
}

func TestTreeMapContains(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2)
    var t1 = IsTrue(t, m.Contains("a"))
    var t2 = IsTrue(t1, m.Contains("b"))
    return IsFalse(t2, m.Contains("c"))
}

func TestTreeMapGet(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2)
    var t1 = IsSome(t, m.Get("a"))
    var t2 = Eq[int](t1, m.Get("a").Get(), 1)
    var t3 = Eq[int](t2, m.Get("b").Get(), 2)
    return IsNone(t3, m.Get("c"))
}

func TestTreeMapGetOrElse(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1)
    var t1 = Eq[int](t, m.GetOrElse("a", 0), 1)
    return Eq[int](t1, m.GetOrElse("b", 42), 42)
}

func TestTreeMapRemove(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3)
    val m2 = m.Remove("b")

    var t1 = Eq[int](t, m2.Size(), 2)
    var t2 = IsTrue(t1, m2.Contains("a"))
    var t3 = IsFalse(t2, m2.Contains("b"))
    return IsTrue(t3, m2.Contains("c"))
}

func TestTreeMapRemoveNonExistent(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1)
    val m2 = m.Remove("b")
    return Eq[int](t, m2.Size(), 1)
}

// === Sorted Order Tests ===

func TestTreeMapSortedOrder(t T) T {
    val m = EmptyTreeMap[int, string]().Put(5, "e").Put(3, "c").Put(1, "a").Put(4, "d").Put(2, "b")
    var keys []int
    m.ForEachKV((k int, v string) => {
        keys = append(keys, k)
    })

    var t1 = Eq[int](t, len(keys), 5)
    var t2 = Eq[int](t1, keys[0], 1)
    var t3 = Eq[int](t2, keys[1], 2)
    var t4 = Eq[int](t3, keys[2], 3)
    var t5 = Eq[int](t4, keys[3], 4)
    return Eq[int](t5, keys[4], 5)
}

// === Min/Max Tests ===

func TestTreeMapMinKey(t T) T {
    val m = EmptyTreeMap[int, string]().Put(5, "e").Put(3, "c").Put(1, "a")
    return Eq[int](t, m.MinKey(), 1)
}

func TestTreeMapMaxKey(t T) T {
    val m = EmptyTreeMap[int, string]().Put(5, "e").Put(3, "c").Put(1, "a")
    return Eq[int](t, m.MaxKey(), 5)
}

func TestTreeMapMinKeyOption(t T) T {
    val m = EmptyTreeMap[int, string]().Put(5, "e").Put(3, "c")
    val empty = EmptyTreeMap[int, string]()

    var t1 = IsSome(t, m.MinKeyOption())
    var t2 = Eq[int](t1, m.MinKeyOption().GetOrElse(0), 3)
    return IsNone(t2, empty.MinKeyOption())
}

func TestTreeMapMaxKeyOption(t T) T {
    val m = EmptyTreeMap[int, string]().Put(5, "e").Put(3, "c")
    val empty = EmptyTreeMap[int, string]()

    var t1 = IsSome(t, m.MaxKeyOption())
    var t2 = Eq[int](t1, m.MaxKeyOption().GetOrElse(0), 5)
    return IsNone(t2, empty.MaxKeyOption())
}

func TestTreeMapMinEntry(t T) T {
    val m = EmptyTreeMap[int, string]().Put(5, "e").Put(3, "c").Put(1, "a")
    val entry = m.MinEntry()
    var t1 = Eq[int](t, entry.V1, 1)
    return Eq[string](t1, entry.V2, "a")
}

func TestTreeMapMaxEntry(t T) T {
    val m = EmptyTreeMap[int, string]().Put(5, "e").Put(3, "c").Put(1, "a")
    val entry = m.MaxEntry()
    var t1 = Eq[int](t, entry.V1, 5)
    return Eq[string](t1, entry.V2, "e")
}

// === Range Tests ===

func TestTreeMapRange(t T) T {
    var m = EmptyTreeMap[int, int]()
    for i := 1; i <= 10; i++ {
        m = m.Put(i, i * 10)
    }
    val rangeMap = m.Range(3, 7)

    var t1 = Eq[int](t, rangeMap.Size(), 5)
    var t2 = IsTrue(t1, rangeMap.Contains(3))
    var t3 = IsTrue(t2, rangeMap.Contains(5))
    var t4 = IsTrue(t3, rangeMap.Contains(7))
    var t5 = IsFalse(t4, rangeMap.Contains(2))
    return IsFalse(t5, rangeMap.Contains(8))
}

func TestTreeMapRangeFrom(t T) T {
    var m = EmptyTreeMap[int, int]()
    for i := 1; i <= 5; i++ {
        m = m.Put(i, i * 10)
    }
    val rangeMap = m.RangeFrom(3)

    var t1 = Eq[int](t, rangeMap.Size(), 3)
    var t2 = IsTrue(t1, rangeMap.Contains(3))
    var t3 = IsTrue(t2, rangeMap.Contains(4))
    var t4 = IsTrue(t3, rangeMap.Contains(5))
    return IsFalse(t4, rangeMap.Contains(2))
}

func TestTreeMapRangeTo(t T) T {
    var m = EmptyTreeMap[int, int]()
    for i := 1; i <= 5; i++ {
        m = m.Put(i, i * 10)
    }
    val rangeMap = m.RangeTo(3)

    var t1 = Eq[int](t, rangeMap.Size(), 3)
    var t2 = IsTrue(t1, rangeMap.Contains(1))
    var t3 = IsTrue(t2, rangeMap.Contains(2))
    var t4 = IsTrue(t3, rangeMap.Contains(3))
    return IsFalse(t4, rangeMap.Contains(4))
}

// === Transformation Tests ===

func TestTreeMapFilter(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3).Put("d", 4)
    val filtered = m.Filter((k string, v int) => v > 2)

    var t1 = Eq[int](t, filtered.Size(), 2)
    var t2 = IsFalse(t1, filtered.Contains("a"))
    var t3 = IsFalse(t2, filtered.Contains("b"))
    var t4 = IsTrue(t3, filtered.Contains("c"))
    return IsTrue(t4, filtered.Contains("d"))
}

func TestTreeMapFilterKeys(t T) T {
    val m = EmptyTreeMap[string, int]().Put("apple", 1).Put("banana", 2).Put("cherry", 3)
    val filtered = m.FilterKeys((k string) => len(k) > 5)

    var t1 = Eq[int](t, filtered.Size(), 2)
    var t2 = IsFalse(t1, filtered.Contains("apple"))
    return IsTrue(t2, filtered.Contains("banana"))
}

func TestTreeMapFilterValues(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3)
    val filtered = m.FilterValues((v int) => v % 2 == 0)

    var t1 = Eq[int](t, filtered.Size(), 1)
    return IsTrue(t1, filtered.Contains("b"))
}

func TestTreeMapMapValues(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3)
    val doubled = m.MapValues[int]((v int) => v * 2)

    var t1 = Eq[int](t, doubled.GetOrElse("a", 0), 2)
    var t2 = Eq[int](t1, doubled.GetOrElse("b", 0), 4)
    return Eq[int](t2, doubled.GetOrElse("c", 0), 6)
}

func TestTreeMapPartition(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3).Put("d", 4)
    val result = m.Partition((k string, v int) => v % 2 == 0)
    val even = result.V1
    val odd = result.V2

    var t1 = Eq[int](t, even.Size(), 2)
    return Eq[int](t1, odd.Size(), 2)
}

// === Reduction Tests ===

func TestTreeMapFoldLeftKV(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3)
    val sum = m.FoldLeftKV[int](0, (acc int, k string, v int) => acc + v)
    return Eq[int](t, sum, 6)
}

// === Predicate Tests ===

func TestTreeMapExists(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3)
    var t1 = IsTrue(t, m.Exists((k string, v int) => v > 2))
    return IsFalse(t1, m.Exists((k string, v int) => v > 10))
}

func TestTreeMapForAll(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 2).Put("b", 4).Put("c", 6)
    var t1 = IsTrue(t, m.ForAll((k string, v int) => v % 2 == 0))
    return IsFalse(t1, m.ForAll((k string, v int) => v < 5))
}

func TestTreeMapFind(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3)
    val found = m.Find((k string, v int) => v == 2)
    var t1 = IsSome(t, found)
    return Eq[string](t1, found.Get().V1, "b")
}

func TestTreeMapCount(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3).Put("d", 4)
    return Eq[int](t, m.Count((k string, v int) => v > 2), 2)
}

func TestTreeMapCollect(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3)
    val result = m.Collect((k string, v int) => {
        if v > 1 {
            return Some(fmt.Sprintf("%s:%d", k, v))
        }
        return None[string]()
    })
    return Eq[int](t, result.Size(), 2)
}

// === Merge Tests ===

func TestTreeMapPutAll(t T) T {
    val m1 = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2)
    val m2 = EmptyTreeMap[string, int]().Put("c", 3).Put("d", 4)
    val merged = m1.PutAll(m2)

    var t1 = Eq[int](t, merged.Size(), 4)
    var t2 = IsTrue(t1, merged.Contains("a"))
    var t3 = IsTrue(t2, merged.Contains("c"))
    return IsTrue(t3, merged.Contains("d"))
}

func TestTreeMapMerge(t T) T {
    val m1 = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2)
    val m2 = EmptyTreeMap[string, int]().Put("b", 3).Put("c", 4)
    val merged = m1.Merge(m2, (v1 int, v2 int) => v1 + v2)

    var t1 = Eq[int](t, merged.Size(), 3)
    var t2 = Eq[int](t1, merged.GetOrElse("a", 0), 1)
    var t3 = Eq[int](t2, merged.GetOrElse("b", 0), 5)
    return Eq[int](t3, merged.GetOrElse("c", 0), 4)
}

// === Key/Value Access Tests ===

func TestTreeMapKeys(t T) T {
    val m = EmptyTreeMap[string, int]().Put("c", 3).Put("a", 1).Put("b", 2)
    val keys = m.Keys()
    var t1 = Eq[int](t, keys.Size(), 3)
    var t2 = IsTrue(t1, keys.Contains("a"))
    var t3 = IsTrue(t2, keys.Contains("b"))
    return IsTrue(t3, keys.Contains("c"))
}

func TestTreeMapValues(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3)
    val values = m.Values()
    return Eq[int](t, values.Size(), 3)
}

func TestTreeMapHead(t T) T {
    val m = EmptyTreeMap[int, string]().Put(3, "c").Put(1, "a").Put(2, "b")
    val head = m.Head()
    var t1 = Eq[int](t, head.V1, 1)
    return Eq[string](t1, head.V2, "a")
}

func TestTreeMapHeadOption(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1)
    val empty = EmptyTreeMap[string, int]()

    var t1 = IsSome(t, m.HeadOption())
    return IsNone(t1, empty.HeadOption())
}

func TestTreeMapLast(t T) T {
    val m = EmptyTreeMap[int, string]().Put(3, "c").Put(1, "a").Put(2, "b")
    val last = m.Last()
    var t1 = Eq[int](t, last.V1, 3)
    return Eq[string](t1, last.V2, "c")
}

func TestTreeMapLastOption(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1)
    val empty = EmptyTreeMap[string, int]()

    var t1 = IsSome(t, m.LastOption())
    return IsNone(t1, empty.LastOption())
}

// === Conversion Tests ===

func TestTreeMapToArray(t T) T {
    val m = EmptyTreeMap[int, string]().Put(3, "c").Put(1, "a").Put(2, "b")
    val arr = m.ToArray()
    var t1 = Eq[int](t, arr.Size(), 3)
    // Should be in sorted key order
    var t2 = Eq[int](t1, arr.Get(0).V1, 1)
    var t3 = Eq[int](t2, arr.Get(1).V1, 2)
    return Eq[int](t3, arr.Get(2).V1, 3)
}

func TestTreeMapToGoMap(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2)
    val goMap = m.ToGoMap()
    var t1 = Eq[int](t, len(goMap), 2)
    return Eq[int](t1, goMap["a"], 1)
}

func TestTreeMapToList(t T) T {
    val m = EmptyTreeMap[int, string]().Put(3, "c").Put(1, "a").Put(2, "b")
    val list = m.ToList()
    var t1 = Eq[int](t, list.Size(), 3)
    // Head should be the min-key entry
    return Eq[int](t1, list.Head().V1, 1)
}

func TestTreeMapToHashMap(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 1).Put("b", 2).Put("c", 3)
    val hm = m.ToHashMap()
    var t1 = Eq[int](t, hm.Size(), 3)
    var t2 = Eq[int](t1, hm.GetOrElse("a", 0), 1)
    return Eq[int](t2, hm.GetOrElse("c", 0), 3)
}

func TestTreeMapFromSlice(t T) T {
    val entries = go_interop.SliceOf[Tuple[string, int]](
        Tuple[string, int](V1 = "a", V2 = 1),
        Tuple[string, int](V1 = "b", V2 = 2),
        Tuple[string, int](V1 = "c", V2 = 3)
    )

    val m = TreeMapFromSlice[string, int](entries)
    var t1 = Eq[int](t, m.Size(), 3)
    var t2 = Eq[int](t1, m.GetOrElse("a", 0), 1)
    return Eq[int](t2, m.GetOrElse("b", 0), 2)
}

// === String Tests ===

func TestTreeMapString(t T) T {
    val empty = EmptyTreeMap[string, int]()
    var t1 = Eq[string](t, empty.String(), "TreeMap()")

    val m = EmptyTreeMap[int, string]().Put(2, "b").Put(1, "a").Put(3, "c")
    // Should be in sorted key order
    return Eq[string](t1, m.String(), "TreeMap(1 -> a, 2 -> b, 3 -> c)")
}

// === Large Map Test ===

func TestTreeMapLarge(t T) T {
    var m = EmptyTreeMap[int, int]()
    for i := 0; i < 1000; i++ {
        m = m.Put(i, i * 2)
    }
    var t1 = Eq[int](t, m.Size(), 1000)
    var t2 = Eq[int](t1, m.GetOrElse(0, -1), 0)
    var t3 = Eq[int](t2, m.GetOrElse(500, -1), 1000)
    var t4 = Eq[int](t3, m.GetOrElse(999, -1), 1998)
    var t5 = Eq[int](t4, m.MinKey(), 0)
    return Eq[int](t5, m.MaxKey(), 999)
}

// === Immutability Test ===

func TestTreeMapImmutability(t T) T {
    val m1 = EmptyTreeMap[string, int]().Put("a", 1)
    val m2 = m1.Put("b", 2)
    val m3 = m1.Remove("a")

    var t1 = Eq[int](t, m1.Size(), 1)
    var t2 = Eq[int](t1, m2.Size(), 2)
    var t3 = Eq[int](t2, m3.Size(), 0)
    return IsTrue(t3, m1.Contains("a"))
}

// === Sorted API Tests ===

func TestTreeMapSorted(t T) T {
    val m = EmptyTreeMap[int, string]().Put(3, "c").Put(1, "a").Put(2, "b")
    val sorted = m.Sorted()
    var t1 = Eq[int](t, sorted.Size(), 3)
    // Already in sorted key order
    var t2 = Eq[int](t1, sorted.Get(0).V1, 1)
    var t3 = Eq[int](t2, sorted.Get(1).V1, 2)
    return Eq[int](t3, sorted.Get(2).V1, 3)
}

func TestTreeMapSortWith(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 3).Put("b", 1).Put("c", 2)
    // Sort by value instead of key
    val sorted = m.SortWith((a Tuple[string, int], b Tuple[string, int]) => a.V2 < b.V2)
    var t1 = Eq[int](t, sorted.Size(), 3)
    var t2 = Eq[string](t1, sorted.Get(0).V1, "b")
    var t3 = Eq[string](t2, sorted.Get(1).V1, "c")
    return Eq[string](t3, sorted.Get(2).V1, "a")
}

func TestTreeMapSortBy(t T) T {
    val m = EmptyTreeMap[string, int]().Put("a", 30).Put("b", 10).Put("c", 20)
    // Sort by value
    val sorted = m.SortBy[int]((entry Tuple[string, int]) => entry.V2)
    var t1 = Eq[int](t, sorted.Size(), 3)
    var t2 = Eq[string](t1, sorted.Get(0).V1, "b")
    var t3 = Eq[string](t2, sorted.Get(1).V1, "c")
    return Eq[string](t3, sorted.Get(2).V1, "a")
}

// === Custom Ordered Key Test ===

type OrderedKey struct {
    Priority int
    Name     string
}

func (a OrderedKey) Compare(b OrderedKey) int {
    if a.Priority < b.Priority { return -1 }
    if a.Priority > b.Priority { return 1 }
    if a.Name < b.Name { return -1 }
    if a.Name > b.Name { return 1 }
    return 0
}

func TestTreeMapCustomOrderedKey(t T) T {
    val k1 = OrderedKey(Priority = 1, Name = "alpha")
    val k2 = OrderedKey(Priority = 2, Name = "beta")
    val k3 = OrderedKey(Priority = 1, Name = "gamma")

    val m = EmptyTreeMap[OrderedKey, string]().Put(k2, "second").Put(k1, "first").Put(k3, "third")
    var t1 = Eq[int](t, m.Size(), 3)
    // Min should be k1 (priority=1, name=alpha)
    var t2 = Eq[string](t1, m.MinEntry().V2, "first")
    // Max should be k2 (priority=2)
    return Eq[string](t2, m.MaxEntry().V2, "second")
}

// === MkString Test ===

func TestTreeMapMkString(t T) T {
    val m = EmptyTreeMap[int, string]().Put(1, "a").Put(2, "b").Put(3, "c")
    return Eq[string](t, m.MkString("; "), "1 -> a; 2 -> b; 3 -> c")
}
