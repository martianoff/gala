package collection_immutable

import (
    "fmt"
    . "martianoff/gala/std"
)

// HashSet is an immutable set with effectively constant time operations.
// It uses a Hash Array Mapped Trie (HAMT) structure similar to Scala's HashSet.
//
// Elements must be either:
// - Primitive types (int, string, bool, etc.) - hashed automatically
// - Types implementing the Hashable interface
//
// Performance characteristics (eC = effectively constant, log32(n)):
// - Add:      O(eC)
// - Remove:   O(eC)
// - Contains: O(eC)
// - Size:     O(1) - cached
// - Union:    O(m) where m is the smaller set
// - Intersect: O(m) where m is the smaller set

// hashSetNode represents a node in the HAMT structure.
// Uses bitmap to track which children exist.
type hashSetNode[T comparable] struct {
    bitmap   uint32
    entries  []T                   // Direct entries at this node (for leaf collisions)
    children []*hashSetNode[T]     // Child nodes (for internal nodes)
    isLeaf   bool
}

// HashSet represents an immutable set.
type HashSet[T comparable] struct {
    root   *hashSetNode[T]
    size   int
}

// EmptyHashSet returns an empty HashSet.
func EmptyHashSet[T comparable]() HashSet[T] {
    var nilRoot *hashSetNode[T] = nil
    return HashSet[T](root = nilRoot, size = 0)
}

// HashSetOf creates a HashSet from variadic arguments.
// Example: HashSetOf[int](1, 2, 3) creates HashSet(1, 2, 3)
func HashSetOf[T comparable](elements ...T) HashSet[T] {
    var result = EmptyHashSet[T]()
    for i := 0; i < len(elements); i++ {
        result = result.Add(elements[i])
    }
    return result
}

// HashSetFromSlice creates a HashSet from a slice.
func HashSetFromSlice[T comparable](elements []T) HashSet[T] {
    var result = EmptyHashSet[T]()
    for i := 0; i < len(elements); i++ {
        result = result.Add(elements[i])
    }
    return result
}

// IsEmpty returns true if the set is empty.
func (s HashSet[T]) IsEmpty() bool = s.size == 0

// NonEmpty returns true if the set is not empty.
func (s HashSet[T]) NonEmpty() bool = s.size > 0

// Size returns the number of elements. O(1) - cached.
func (s HashSet[T]) Size() int = s.size

// Length is an alias for Size.
func (s HashSet[T]) Length() int = s.size

// hash computes a hash code for a value.
// Priority:
// 1. For primitives (int, string, bool, etc.), use built-in efficient hashing
// 2. If the value implements Hashable, use its Hash() method
// 3. For other types, panic - they must implement Hashable
func hash[T comparable](value T) uint32 {
    val v any = value

    // Check primitives first (common case), then Hashable interface
    val result = v match {
        case i: int => HashInt(int64(i))
        case s: string => HashString(s)
        case i: int64 => HashInt(i)
        case i: int32 => HashInt(int64(i))
        case u: uint => HashUint(uint64(u))
        case u: uint64 => HashUint(u)
        case u: uint32 => HashUint(uint64(u))
        case b: bool => HashBool(b)
        case i: int8 => HashInt(int64(i))
        case i: int16 => HashInt(int64(i))
        case u: uint8 => HashUint(uint64(u))
        case u: uint16 => HashUint(uint64(u))
        case f: float64 => HashUint(uint64(f))
        case f: float32 => HashUint(uint64(f))
        case h: Hashable => h.Hash()
        case _ => panicNotHashable(v)
    }
    return result
}

// panicNotHashable panics with a helpful error message for types that don't implement Hashable.
func panicNotHashable(v any) uint32 {
    panic(fmt.Sprintf("HashSet: type %T must implement std.Hashable interface", v))
}

// bitpos returns the bit position for a hash at a given level.
func bitpos(hashCode uint32, level int) uint32 {
    var shift = uint(level * 5)
    var idx = (hashCode >> shift) & 31
    return uint32(1) << idx
}

// index returns the array index for a bit position in a bitmap.
func index(bitmap uint32, bit uint32) int {
    return popcount(bitmap & (bit - 1))
}

// popcount returns the number of set bits in a uint32.
func popcount(x uint32) int {
    var count = 0
    for x != 0 {
        count++
        x = x & (x - 1)
    }
    return count
}

// Contains checks if the set contains the given element. O(eC).
func (s HashSet[T]) Contains(elem T) bool {
    if s.root == nil {
        return false
    }
    val hashCode = hash[T](elem)
    return containsInNode[T](s.root, elem, hashCode, 0)
}

// containsInNode searches for an element in a node.
func containsInNode[T comparable](node *hashSetNode[T], elem T, hashCode uint32, level int) bool {
    if node.isLeaf {
        // Check entries at this leaf
        for i := 0; i < len(node.entries); i++ {
            if node.entries[i] == elem {
                return true
            }
        }
        return false
    }

    val bit = bitpos(hashCode, level)
    if (node.bitmap & bit) == 0 {
        return false
    }

    val idx = index(node.bitmap, bit)
    return containsInNode[T](node.children[idx], elem, hashCode, level + 1)
}

// Add adds an element to the set. Returns a new set with the element. O(eC).
func (s HashSet[T]) Add(elem T) HashSet[T] {
    val hashCode = hash[T](elem)

    // Check if already contains (single hash computation)
    if s.root != nil && containsInNode[T](s.root, elem, hashCode, 0) {
        return s
    }

    var newRoot *hashSetNode[T]
    if s.root == nil {
        // Create new leaf node
        var entries []T
        entries = append(entries, elem)
        newRoot = &hashSetNode[T](entries = entries, isLeaf = true)
    } else {
        newRoot = addToNode[T](s.root, elem, hashCode, 0)
    }

    return HashSet[T](root = newRoot, size = s.size + 1)
}

// addToNode adds an element to a node, returning a new node.
func addToNode[T comparable](node *hashSetNode[T], elem T, hashCode uint32, level int) *hashSetNode[T] {
    if node.isLeaf {
        // Add to leaf's entries or expand to internal node
        if level >= 6 {
            // Max depth reached, just add to entries (hash collision)
            var newEntries []T
            for i := 0; i < len(node.entries); i++ {
                newEntries = append(newEntries, node.entries[i])
            }
            newEntries = append(newEntries, elem)
            return &hashSetNode[T](entries = newEntries, isLeaf = true)
        }

        // Create a new internal node and distribute elements
        var newNode = &hashSetNode[T](bitmap = uint32(0), isLeaf = false)

        // Add existing entries
        for i := 0; i < len(node.entries); i++ {
            val existingHash = hash[T](node.entries[i])
            newNode = insertIntoInternalNode[T](newNode, node.entries[i], existingHash, level)
        }

        // Add new element
        return insertIntoInternalNode[T](newNode, elem, hashCode, level)
    }

    // Internal node
    val bit = bitpos(hashCode, level)
    val idx = index(node.bitmap, bit)

    if (node.bitmap & bit) == 0 {
        // No child at this position, create new leaf
        var newEntries []T
        newEntries = append(newEntries, elem)
        val newLeaf = &hashSetNode[T](entries = newEntries, isLeaf = true)

        // Copy children and insert new leaf
        var newChildren []*hashSetNode[T]
        for i := 0; i < idx; i++ {
            newChildren = append(newChildren, node.children[i])
        }
        newChildren = append(newChildren, newLeaf)
        for i := idx; i < len(node.children); i++ {
            newChildren = append(newChildren, node.children[i])
        }

        return &hashSetNode[T](bitmap = node.bitmap | bit, children = newChildren, isLeaf = false)
    }

    // Child exists, recurse
    val newChild = addToNode[T](node.children[idx], elem, hashCode, level + 1)

    // Copy children with updated child
    var newChildren []*hashSetNode[T]
    for i := 0; i < len(node.children); i++ {
        if i == idx {
            newChildren = append(newChildren, newChild)
        } else {
            newChildren = append(newChildren, node.children[i])
        }
    }

    return &hashSetNode[T](bitmap = node.bitmap, children = newChildren, isLeaf = false)
}

// insertIntoInternalNode inserts an element into an internal node.
func insertIntoInternalNode[T comparable](node *hashSetNode[T], elem T, hashCode uint32, level int) *hashSetNode[T] {
    val bit = bitpos(hashCode, level)
    val idx = index(node.bitmap, bit)

    if (node.bitmap & bit) == 0 {
        // No child at this position, create new leaf
        var newEntries []T
        newEntries = append(newEntries, elem)
        val newLeaf = &hashSetNode[T](entries = newEntries, isLeaf = true)

        // Copy children and insert new leaf
        var newChildren []*hashSetNode[T]
        for i := 0; i < idx; i++ {
            newChildren = append(newChildren, node.children[i])
        }
        newChildren = append(newChildren, newLeaf)
        for i := idx; i < len(node.children); i++ {
            newChildren = append(newChildren, node.children[i])
        }

        return &hashSetNode[T](bitmap = node.bitmap | bit, children = newChildren, isLeaf = false)
    }

    // Child exists, recurse
    val newChild = addToNode[T](node.children[idx], elem, hashCode, level + 1)

    // Copy children with updated child
    var newChildren []*hashSetNode[T]
    for i := 0; i < len(node.children); i++ {
        if i == idx {
            newChildren = append(newChildren, newChild)
        } else {
            newChildren = append(newChildren, node.children[i])
        }
    }

    return &hashSetNode[T](bitmap = node.bitmap, children = newChildren, isLeaf = false)
}

// Remove removes an element from the set. Returns a new set without the element. O(eC).
func (s HashSet[T]) Remove(elem T) HashSet[T] {
    val hashCode = hash[T](elem)

    // Check if contains (single hash computation)
    if s.root == nil || !containsInNode[T](s.root, elem, hashCode, 0) {
        return s
    }

    if s.size == 1 {
        return EmptyHashSet[T]()
    }

    val newRoot = removeFromNode[T](s.root, elem, hashCode, 0)
    return HashSet[T](root = newRoot, size = s.size - 1)
}

// removeFromNode removes an element from a node, returning a new node.
func removeFromNode[T comparable](node *hashSetNode[T], elem T, hashCode uint32, level int) *hashSetNode[T] {
    if node.isLeaf {
        var newEntries []T
        for i := 0; i < len(node.entries); i++ {
            if node.entries[i] != elem {
                newEntries = append(newEntries, node.entries[i])
            }
        }
        if len(newEntries) == 0 {
            return nil
        }
        return &hashSetNode[T](entries = newEntries, isLeaf = true)
    }

    val bit = bitpos(hashCode, level)
    val idx = index(node.bitmap, bit)

    if (node.bitmap & bit) == 0 {
        return node
    }

    val newChild = removeFromNode[T](node.children[idx], elem, hashCode, level + 1)

    if newChild == nil {
        // Child is now empty, remove it
        if popcount(node.bitmap) == 1 {
            return nil
        }

        var newChildren []*hashSetNode[T]
        for i := 0; i < len(node.children); i++ {
            if i != idx {
                newChildren = append(newChildren, node.children[i])
            }
        }
        return &hashSetNode[T](bitmap = node.bitmap & (^bit), children = newChildren, isLeaf = false)
    }

    // Copy children with updated child
    var newChildren []*hashSetNode[T]
    for i := 0; i < len(node.children); i++ {
        if i == idx {
            newChildren = append(newChildren, newChild)
        } else {
            newChildren = append(newChildren, node.children[i])
        }
    }

    return &hashSetNode[T](bitmap = node.bitmap, children = newChildren, isLeaf = false)
}

// AddAll adds all elements from another set. Returns a new set.
func (s HashSet[T]) AddAll(other HashSet[T]) HashSet[T] {
    return other.FoldLeft[HashSet[T]](s, (acc HashSet[T], elem T) => acc.Add(elem))
}

// Union returns a new set containing all elements from both sets.
func (s HashSet[T]) Union(other HashSet[T]) HashSet[T] = s.AddAll(other)

// Intersect returns a new set containing only elements present in both sets.
func (s HashSet[T]) Intersect(other HashSet[T]) HashSet[T] {
    // Iterate over the smaller set for efficiency
    var smaller HashSet[T]
    var larger HashSet[T]
    if s.size <= other.size {
        smaller = s
        larger = other
    } else {
        smaller = other
        larger = s
    }

    return smaller.FoldLeft[HashSet[T]](EmptyHashSet[T](), (acc HashSet[T], elem T) => {
        if larger.Contains(elem) {
            return acc.Add(elem)
        }
        return acc
    })
}

// Diff returns a new set containing elements in this set but not in other.
func (s HashSet[T]) Diff(other HashSet[T]) HashSet[T] {
    return s.FoldLeft[HashSet[T]](EmptyHashSet[T](), (acc HashSet[T], elem T) => {
        if !other.Contains(elem) {
            return acc.Add(elem)
        }
        return acc
    })
}

// SubsetOf returns true if this set is a subset of other.
func (s HashSet[T]) SubsetOf(other HashSet[T]) bool {
    if s.size > other.size {
        return false
    }
    return s.FoldLeft[bool](true, (acc bool, elem T) => acc && other.Contains(elem))
}

// ForEach applies a function to each element for side effects.
func (s HashSet[T]) ForEach(f func(T) any) {
    if s.root != nil {
        forEachInNode[T](s.root, f)
    }
}

// forEachInNode traverses a node and applies f to each element.
func forEachInNode[T comparable](node *hashSetNode[T], f func(T) any) {
    if node.isLeaf {
        for i := 0; i < len(node.entries); i++ {
            f(node.entries[i])
        }
        return
    }

    for i := 0; i < len(node.children); i++ {
        forEachInNode[T](node.children[i], f)
    }
}

// MapHashSet applies a function to each element and returns a new set.
// Note: Defined as standalone function to preserve type constraints.
func MapHashSet[T comparable, U comparable](s HashSet[T], f func(T) U) HashSet[U] {
    return s.FoldLeft[HashSet[U]](EmptyHashSet[U](), (acc HashSet[U], elem T) => acc.Add(f(elem)))
}

// FlatMapHashSet applies a function that returns a set to each element and flattens.
// Note: Defined as standalone function to preserve type constraints.
func FlatMapHashSet[T comparable, U comparable](s HashSet[T], f func(T) HashSet[U]) HashSet[U] {
    return s.FoldLeft[HashSet[U]](EmptyHashSet[U](), (acc HashSet[U], elem T) => acc.AddAll(f(elem)))
}

// Filter returns a new set with only elements that satisfy the predicate.
func (s HashSet[T]) Filter(p func(T) bool) HashSet[T] {
    return s.FoldLeft[HashSet[T]](EmptyHashSet[T](), (acc HashSet[T], elem T) => {
        if p(elem) {
            return acc.Add(elem)
        }
        return acc
    })
}

// FilterNot returns a new set with elements that do not satisfy the predicate.
func (s HashSet[T]) FilterNot(p func(T) bool) HashSet[T] = s.Filter((elem T) => !p(elem))

// Partition splits the set into two sets based on a predicate.
func (s HashSet[T]) Partition(p func(T) bool) Tuple[HashSet[T], HashSet[T]] {
    var left = s.Filter(p)
    var right = s.FilterNot(p)
    return Tuple[HashSet[T], HashSet[T]](V1 = left, V2 = right)
}

// FoldLeft applies a binary operator from left to right.
func (s HashSet[T]) FoldLeft[U any](initial U, f func(U, T) U) U {
    var acc = initial
    s.ForEach((elem T) => {
        acc = f(acc, elem)
        return nil
    })
    return acc
}

// Reduce applies a binary operator, starting with the first element.
// Panics if the set is empty.
func (s HashSet[T]) Reduce(f func(T, T) T) T {
    if s.size == 0 {
        panic("HashSet.Reduce on empty set")
    }
    var first = true
    var acc T
    s.ForEach((elem T) => {
        if first {
            acc = elem
            first = false
        } else {
            acc = f(acc, elem)
        }
        return nil
    })
    return acc
}

// ReduceOption is like Reduce but returns None for empty set.
func (s HashSet[T]) ReduceOption(f func(T, T) T) Option[T] {
    if s.size == 0 {
        return None[T]()
    }
    return Some[T](s.Reduce(f))
}

// Exists returns true if any element satisfies the predicate.
func (s HashSet[T]) Exists(p func(T) bool) bool {
    return s.FoldLeft[bool](false, (acc bool, elem T) => acc || p(elem))
}

// ForAll returns true if all elements satisfy the predicate.
func (s HashSet[T]) ForAll(p func(T) bool) bool {
    return s.FoldLeft[bool](true, (acc bool, elem T) => acc && p(elem))
}

// Find returns the first element that satisfies the predicate.
func (s HashSet[T]) Find(p func(T) bool) Option[T] {
    return s.FoldLeft[Option[T]](None[T](), (acc Option[T], elem T) => {
        if acc.IsEmpty() && p(elem) {
            return Some[T](elem)
        }
        return acc
    })
}

// Count returns the number of elements satisfying the predicate.
func (s HashSet[T]) Count(p func(T) bool) int {
    return s.FoldLeft[int](0, (acc int, elem T) => {
        if p(elem) {
            return acc + 1
        }
        return acc
    })
}

// Head returns an arbitrary element from the set.
// Panics if the set is empty.
func (s HashSet[T]) Head() T {
    if s.size == 0 {
        panic("HashSet.Head on empty set")
    }
    var result T
    var found = false
    s.ForEach((elem T) => {
        if !found {
            result = elem
            found = true
        }
        return nil
    })
    return result
}

// HeadOption returns an arbitrary element wrapped in Option.
func (s HashSet[T]) HeadOption() Option[T] {
    if s.size == 0 {
        return None[T]()
    }
    return Some[T](s.Head())
}

// ToSlice converts the set to a Go slice.
func (s HashSet[T]) ToSlice() []T {
    var result []T
    s.ForEach((elem T) => {
        result = append(result, elem)
        return nil
    })
    return result
}

// ToList converts the set to a List.
func (s HashSet[T]) ToList() List[T] {
    return s.FoldLeft[List[T]](emptyList[T](), (acc List[T], elem T) => consList[T](elem, acc))
}

// ToArray converts the set to an Array.
func (s HashSet[T]) ToArray() Array[T] {
    return s.FoldLeft[Array[T]](EmptyArray[T](), (acc Array[T], elem T) => acc.Append(elem))
}

// String returns a string representation of the set.
func (s HashSet[T]) String() string {
    if s.size == 0 {
        return "HashSet()"
    }
    var result = "HashSet("
    var first = true
    s.ForEach((elem T) => {
        if !first {
            result = result + ", "
        }
        result = result + fmt.Sprintf("%v", elem)
        first = false
        return nil
    })
    return result + ")"
}

// HashSetEmpty extractor for pattern matching on empty sets.
type HashSetEmpty struct {}
func (hse HashSetEmpty) Unapply(s any) Option[bool] = s match {
    case set: HashSet[_] if set.size == 0 => Some[bool](true)
    case _ => None[bool]()
}

// HashSetNonEmpty extractor for pattern matching on non-empty sets.
type HashSetNonEmpty struct {}
func (hsne HashSetNonEmpty) Unapply(s any) Option[any] = s match {
    case set: HashSet[_] if set.size > 0 => Some[any](set)
    case _ => None[any]()
}
