package main

import (
    . "martianoff/gala/test"
    . "martianoff/gala/collection_immutable"
)

// ============================================================================
// COMPLEX DATA VALIDATION TESTS - Array
// ============================================================================

// Test Array with large scale data (stress test tree structure)
func TestArrayLargeScale(t T) T {
    // Build array with 10000 elements
    var arr = EmptyArray[int]()
    for i := 0; i < 10000; i++ {
        arr = arr.Append(i)
    }

    // Verify all elements are correct
    var t1 = Eq[int](t, arr.Length(), 10000)
    var allCorrect = true
    for i := 0; i < 10000; i++ {
        if arr.Get(i) != i {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}

// Test Array structural integrity after many prepends (prefix consolidation)
func TestArrayPrependStress(t T) T {
    var arr = EmptyArray[int]()
    // Prepend 100 elements - forces multiple prefix consolidations
    for i := 100; i >= 1; i-- {
        arr = arr.Prepend(i)
    }

    var t1 = Eq[int](t, arr.Length(), 100)
    // Verify order is correct (1, 2, 3, ..., 100)
    var allCorrect = true
    for i := 0; i < 100; i++ {
        if arr.Get(i) != (i + 1) {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}

// Test Array with mixed operations maintaining integrity
func TestArrayMixedOperationsIntegrity(t T) T {
    var arr = EmptyArray[int]()

    // Mix of prepends and appends
    for i := 0; i < 50; i++ {
        arr = arr.Append(100 + i)   // Append 100-149
        arr = arr.Prepend(49 - i)   // Prepend 49, 48, ..., 0
    }

    // Should have 100 elements: 0-49 (prepended) then 100-149 (appended)
    var t1 = Eq[int](t, arr.Length(), 100)

    // Check first half (prepended in reverse, so 0-49)
    var firstHalfCorrect = true
    for i := 0; i < 50; i++ {
        if arr.Get(i) != i {
            firstHalfCorrect = false
        }
    }

    // Check second half (appended, so 100-149)
    var secondHalfCorrect = true
    for i := 0; i < 50; i++ {
        if arr.Get(50 + i) != (100 + i) {
            secondHalfCorrect = false
        }
    }

    var t2 = IsTrue(t1, firstHalfCorrect)
    return IsTrue(t2, secondHalfCorrect)
}

// Test Array Update across tree boundaries
func TestArrayUpdateAcrossTree(t T) T {
    var arr = EmptyArray[int]()
    for i := 0; i < 100; i++ {
        arr = arr.Append(i)
    }

    // Update elements at different tree positions
    var updated = arr.Updated(0, 1000)   // First element
    updated = updated.Updated(31, 1031)   // Last of first leaf
    updated = updated.Updated(32, 1032)   // First of second leaf
    updated = updated.Updated(63, 1063)   // Last of second leaf
    updated = updated.Updated(99, 1099)   // Last element

    var t1 = Eq[int](t, updated.Get(0), 1000)
    var t2 = Eq[int](t1, updated.Get(31), 1031)
    var t3 = Eq[int](t2, updated.Get(32), 1032)
    var t4 = Eq[int](t3, updated.Get(63), 1063)
    var t5 = Eq[int](t4, updated.Get(99), 1099)

    // Original unchanged
    var t6 = Eq[int](t5, arr.Get(0), 0)
    return Eq[int](t6, arr.Get(99), 99)
}

// Test Array Take/Drop preserves data
func TestArrayTakeDropDataIntegrity(t T) T {
    var arr = EmptyArray[int]()
    for i := 0; i < 100; i++ {
        arr = arr.Append(i * 2)
    }

    var taken = arr.Take(50)
    var dropped = arr.Drop(50)

    // Verify taken has first 50 elements
    var t1 = Eq[int](t, taken.Length(), 50)
    var takenCorrect = true
    for i := 0; i < 50; i++ {
        if taken.Get(i) != (i * 2) {
            takenCorrect = false
        }
    }

    // Verify dropped has last 50 elements
    var t2 = Eq[int](t1, dropped.Length(), 50)
    var droppedCorrect = true
    for i := 0; i < 50; i++ {
        if dropped.Get(i) != ((50 + i) * 2) {
            droppedCorrect = false
        }
    }

    var t3 = IsTrue(t2, takenCorrect)
    return IsTrue(t3, droppedCorrect)
}

// Test Array Map produces correct transformation
func TestArrayMapDataIntegrity(t T) T {
    var arr = EmptyArray[int]()
    for i := 0; i < 100; i++ {
        arr = arr.Append(i)
    }

    var doubled = arr.Map[int]((x int) => x * 2)
    var squared = arr.Map[int]((x int) => x * x)

    var t1 = Eq[int](t, doubled.Length(), 100)
    var t2 = Eq[int](t1, squared.Length(), 100)

    var doubledCorrect = true
    var squaredCorrect = true
    for i := 0; i < 100; i++ {
        if doubled.Get(i) != (i * 2) {
            doubledCorrect = false
        }
        if squared.Get(i) != (i * i) {
            squaredCorrect = false
        }
    }

    var t3 = IsTrue(t2, doubledCorrect)
    return IsTrue(t3, squaredCorrect)
}

// Test Array Filter preserves only matching elements
func TestArrayFilterDataIntegrity(t T) T {
    var arr = EmptyArray[int]()
    for i := 0; i < 100; i++ {
        arr = arr.Append(i)
    }

    var evens = arr.Filter((x int) => x % 2 == 0)
    var multiplesOf10 = arr.Filter((x int) => x % 10 == 0)

    var t1 = Eq[int](t, evens.Length(), 50)
    var t2 = Eq[int](t1, multiplesOf10.Length(), 10)

    // Verify evens are actually even
    var evensCorrect = true
    for i := 0; i < evens.Length(); i++ {
        if evens.Get(i) % 2 != 0 {
            evensCorrect = false
        }
    }

    // Verify multiples of 10
    var multiplesCorrect = true
    for i := 0; i < multiplesOf10.Length(); i++ {
        if multiplesOf10.Get(i) % 10 != 0 {
            multiplesCorrect = false
        }
    }

    var t3 = IsTrue(t2, evensCorrect)
    return IsTrue(t3, multiplesCorrect)
}

// Test Array FoldLeft produces correct accumulation
func TestArrayFoldDataIntegrity(t T) T {
    var arr = EmptyArray[int]()
    for i := 1; i <= 100; i++ {
        arr = arr.Append(i)
    }

    // Sum 1 to 100 = 5050
    var sum = arr.FoldLeft[int](0, (acc int, x int) => acc + x)
    var t1 = Eq[int](t, sum, 5050)

    // Product of first 5: 1*2*3*4*5 = 120
    var first5 = arr.Take(5)
    var product = first5.FoldLeft[int](1, (acc int, x int) => acc * x)
    return Eq[int](t1, product, 120)
}

// Test Array Reverse produces correct order
func TestArrayReverseDataIntegrity(t T) T {
    var arr = EmptyArray[int]()
    for i := 0; i < 100; i++ {
        arr = arr.Append(i)
    }

    var reversed = arr.Reverse()
    var t1 = Eq[int](t, reversed.Length(), 100)

    var allCorrect = true
    for i := 0; i < 100; i++ {
        if reversed.Get(i) != (99 - i) {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}

// Test Array Slice produces correct subarray
func TestArraySliceDataIntegrity(t T) T {
    var arr = EmptyArray[int]()
    for i := 0; i < 100; i++ {
        arr = arr.Append(i)
    }

    var slice1 = arr.Slice(25, 75)
    var t1 = Eq[int](t, slice1.Length(), 50)

    var allCorrect = true
    for i := 0; i < 50; i++ {
        if slice1.Get(i) != (25 + i) {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}

// ============================================================================
// COMPLEX DATA VALIDATION TESTS - List
// ============================================================================

// Test List with large scale data
func TestListLargeScale(t T) T {
    var list = EmptyList[int]()
    for i := 999; i >= 0; i-- {
        list = list.Prepend(i)
    }

    var t1 = Eq[int](t, list.Length(), 1000)
    var allCorrect = true
    for i := 0; i < 1000; i++ {
        if list.Get(i) != i {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}

// Test List structural integrity through many tail operations
func TestListTailChainIntegrity(t T) T {
    var list = ListOf[int](1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    var lengths []int
    var heads []int
    var current = list
    for !current.IsEmpty() {
        lengths = append(lengths, current.Length())
        heads = append(heads, current.Head())
        current = current.Tail()
    }

    // Should have 10 iterations
    var t1 = Eq[int](t, len(lengths), 10)

    // Each tail should have decreasing length
    var lengthsCorrect = true
    for i := 0; i < len(lengths); i++ {
        if lengths[i] != (10 - i) {
            lengthsCorrect = false
        }
    }

    // First element of each tail should be i+1
    var headsCorrect = true
    for i := 0; i < len(heads); i++ {
        if heads[i] != (i + 1) {
            headsCorrect = false
        }
    }

    var t2 = IsTrue(t1, lengthsCorrect)
    return IsTrue(t2, headsCorrect)
}

// Test List Map produces correct transformation
func TestListMapDataIntegrity(t T) T {
    var list = EmptyList[int]()
    for i := 99; i >= 0; i-- {
        list = list.Prepend(i)
    }

    var doubled = list.Map[int]((x int) => x * 2)

    var t1 = Eq[int](t, doubled.Length(), 100)
    var allCorrect = true
    for i := 0; i < 100; i++ {
        if doubled.Get(i) != (i * 2) {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}

// Test List Filter preserves only matching elements
func TestListFilterDataIntegrity(t T) T {
    var list = EmptyList[int]()
    for i := 99; i >= 0; i-- {
        list = list.Prepend(i)
    }

    var evens = list.Filter((x int) => x % 2 == 0)

    var t1 = Eq[int](t, evens.Length(), 50)
    var allEven = true
    for i := 0; i < evens.Length(); i++ {
        if evens.Get(i) % 2 != 0 {
            allEven = false
        }
    }
    return IsTrue(t1, allEven)
}

// Test List FoldLeft produces correct accumulation
func TestListFoldDataIntegrity(t T) T {
    var list = EmptyList[int]()
    for i := 100; i >= 1; i-- {
        list = list.Prepend(i)
    }

    // Sum 1 to 100 = 5050
    var sum = list.FoldLeft[int](0, (acc int, x int) => acc + x)
    var t1 = Eq[int](t, sum, 5050)

    // Product of first 5: 1*2*3*4*5 = 120
    var first5 = list.Take(5)
    var product = first5.FoldLeft[int](1, (acc int, x int) => acc * x)
    return Eq[int](t1, product, 120)
}

// Test List Reverse produces correct order
func TestListReverseDataIntegrity(t T) T {
    var list = EmptyList[int]()
    for i := 99; i >= 0; i-- {
        list = list.Prepend(i)
    }

    var reversed = list.Reverse()
    var t1 = Eq[int](t, reversed.Length(), 100)

    var allCorrect = true
    for i := 0; i < 100; i++ {
        if reversed.Get(i) != (99 - i) {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}

// ============================================================================
// IMMUTABILITY VERIFICATION TESTS
// ============================================================================

// Test Array immutability through chain of operations
func TestArrayImmutabilityChain(t T) T {
    var original = EmptyArray[int]()
    for i := 0; i < 50; i++ {
        original = original.Append(i)
    }

    // Create multiple derived arrays
    var appended = original.Append(999)
    var prepended = original.Prepend(-1)
    var updated = original.Updated(25, 999)
    var taken = original.Take(25)
    var dropped = original.Drop(25)
    var mapped = original.Map[int]((x int) => x * 2)
    var filtered = original.Filter((x int) => x % 2 == 0)

    // Original must be unchanged
    var t1 = Eq[int](t, original.Length(), 50)
    var t2 = Eq[int](t1, original.Get(0), 0)
    var t3 = Eq[int](t2, original.Get(25), 25)
    var t4 = Eq[int](t3, original.Get(49), 49)

    // Derived arrays have expected values
    var t5 = Eq[int](t4, appended.Length(), 51)
    var t6 = Eq[int](t5, appended.Get(50), 999)

    var t7 = Eq[int](t6, prepended.Length(), 51)
    var t8 = Eq[int](t7, prepended.Get(0), -1)

    var t9 = Eq[int](t8, updated.Get(25), 999)
    var t10 = Eq[int](t9, taken.Length(), 25)
    var t11 = Eq[int](t10, dropped.Length(), 25)
    var t12 = Eq[int](t11, mapped.Get(10), 20)
    return Eq[int](t12, filtered.Length(), 25)
}

// Test List immutability through chain of operations
func TestListImmutabilityChain(t T) T {
    var original = EmptyList[int]()
    for i := 49; i >= 0; i-- {
        original = original.Prepend(i)
    }

    // Create multiple derived lists
    var appended = original.Append(999)
    var prepended = original.Prepend(-1)
    var taken = original.Take(25)
    var dropped = original.Drop(25)
    var mapped = original.Map[int]((x int) => x * 2)
    var filtered = original.Filter((x int) => x % 2 == 0)

    // Original must be unchanged
    var t1 = Eq[int](t, original.Length(), 50)
    var t2 = Eq[int](t1, original.Get(0), 0)
    var t3 = Eq[int](t2, original.Get(25), 25)
    var t4 = Eq[int](t3, original.Get(49), 49)

    // Derived lists have expected values
    var t5 = Eq[int](t4, appended.Length(), 51)
    var t6 = Eq[int](t5, appended.Last(), 999)

    var t7 = Eq[int](t6, prepended.Length(), 51)
    var t8 = Eq[int](t7, prepended.Get(0), -1)

    var t9 = Eq[int](t8, taken.Length(), 25)
    var t10 = Eq[int](t9, dropped.Length(), 25)
    var t11 = Eq[int](t10, mapped.Get(10), 20)
    return Eq[int](t11, filtered.Length(), 25)
}

// ============================================================================
// EDGE CASES AND BOUNDARY TESTS
// ============================================================================

// Test Array boundary conditions at branching factor (32)
func TestArrayBranchingBoundary(t T) T {
    // Test at exactly 32 elements (single full leaf)
    var arr32 = EmptyArray[int]()
    for i := 0; i < 32; i++ {
        arr32 = arr32.Append(i)
    }
    var t1 = Eq[int](t, arr32.Length(), 32)
    var t2 = Eq[int](t1, arr32.Get(0), 0)
    var t3 = Eq[int](t2, arr32.Get(31), 31)

    // Test at 33 elements (triggers second leaf)
    var arr33 = arr32.Append(32)
    var t4 = Eq[int](t3, arr33.Length(), 33)
    var t5 = Eq[int](t4, arr33.Get(32), 32)

    // Test at 64 elements (two full leaves)
    var arr64 = EmptyArray[int]()
    for i := 0; i < 64; i++ {
        arr64 = arr64.Append(i)
    }
    var t6 = Eq[int](t5, arr64.Length(), 64)
    var t7 = Eq[int](t6, arr64.Get(31), 31)
    return Eq[int](t7, arr64.Get(32), 32)
}

// Test Array with 1024 elements (triggers depth 3)
func TestArrayDepth3(t T) T {
    var arr = EmptyArray[int]()
    for i := 0; i < 1024; i++ {
        arr = arr.Append(i)
    }

    var t1 = Eq[int](t, arr.Length(), 1024)
    var t2 = Eq[int](t1, arr.Get(0), 0)
    var t3 = Eq[int](t2, arr.Get(511), 511)
    var t4 = Eq[int](t3, arr.Get(512), 512)
    return Eq[int](t4, arr.Get(1023), 1023)
}

// Test empty collection operations don't panic
func TestEmptyCollectionOperations(t T) T {
    var emptyArr = EmptyArray[int]()
    var emptyList = EmptyList[int]()

    // These should return empty results, not panic
    var t1 = Eq[int](t, emptyArr.Take(10).Length(), 0)
    var t2 = Eq[int](t1, emptyArr.Drop(10).Length(), 0)
    var t3 = Eq[int](t2, emptyArr.Filter((x int) => true).Length(), 0)
    var t4 = Eq[int](t3, emptyArr.Map[int]((x int) => x).Length(), 0)

    var t5 = Eq[int](t4, emptyList.Take(10).Length(), 0)
    var t6 = Eq[int](t5, emptyList.Drop(10).Length(), 0)
    var t7 = Eq[int](t6, emptyList.Filter((x int) => true).Length(), 0)
    return Eq[int](t7, emptyList.Map[int]((x int) => x).Length(), 0)
}

// Test single element operations
func TestSingleElementOperations(t T) T {
    var arr = ArrayOf[int](42)
    var list = ListOf[int](42)

    var t1 = Eq[int](t, arr.Head(), 42)
    var t2 = Eq[int](t1, arr.Last(), 42)
    var t3 = Eq[int](t2, arr.Tail().Length(), 0)

    var t4 = Eq[int](t3, list.Head(), 42)
    var t5 = Eq[int](t4, list.Last(), 42)
    return Eq[int](t5, list.Tail().Length(), 0)
}

// Test FlatMap data integrity
func TestArrayFlatMapDataIntegrity(t T) T {
    var arr = ArrayOf[int](1, 2, 3)

    // Each element becomes [x, x*10]
    var flattened = arr.FlatMap[int]((x int) => ArrayOf[int](x, x * 10))

    var t1 = Eq[int](t, flattened.Length(), 6)
    var t2 = Eq[int](t1, flattened.Get(0), 1)
    var t3 = Eq[int](t2, flattened.Get(1), 10)
    var t4 = Eq[int](t3, flattened.Get(2), 2)
    var t5 = Eq[int](t4, flattened.Get(3), 20)
    var t6 = Eq[int](t5, flattened.Get(4), 3)
    return Eq[int](t6, flattened.Get(5), 30)
}

// NOTE: Tests for Concat, Partition, Zip, and ZipWithIndex are omitted
// because the transpiler currently wraps Tuple fields with Immutable[T],
// making direct field access incompatible with the test framework.
// These features are tested indirectly through other tests.

// Test Distinct data integrity
func TestArrayDistinctDataIntegrity(t T) T {
    var arr = ArrayOf[int](1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5)
    var distinct = arr.Distinct()

    var t1 = Eq[int](t, distinct.Length(), 5)

    var allCorrect = true
    for i := 0; i < 5; i++ {
        if distinct.Get(i) != (i + 1) {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}

// Test Grouped data integrity
func TestArrayGroupedDataIntegrity(t T) T {
    var arr = EmptyArray[int]()
    for i := 1; i <= 10; i++ {
        arr = arr.Append(i)
    }

    var grouped = arr.Grouped(3)
    var t1 = Eq[int](t, grouped.Length(), 4)
    var t2 = Eq[int](t1, grouped.Get(0).Length(), 3)  // [1,2,3]
    var t3 = Eq[int](t2, grouped.Get(1).Length(), 3)  // [4,5,6]
    var t4 = Eq[int](t3, grouped.Get(2).Length(), 3)  // [7,8,9]
    var t5 = Eq[int](t4, grouped.Get(3).Length(), 1)  // [10]

    var t6 = Eq[int](t5, grouped.Get(0).Get(0), 1)
    return Eq[int](t6, grouped.Get(3).Get(0), 10)
}

// Test Sliding window data integrity
func TestArraySlidingDataIntegrity(t T) T {
    var arr = ArrayOf[int](1, 2, 3, 4, 5)
    var windows = arr.Sliding(3)

    var t1 = Eq[int](t, windows.Length(), 3)  // [1,2,3], [2,3,4], [3,4,5]

    var t2 = Eq[int](t1, windows.Get(0).Get(0), 1)
    var t3 = Eq[int](t2, windows.Get(0).Get(2), 3)
    var t4 = Eq[int](t3, windows.Get(1).Get(0), 2)
    var t5 = Eq[int](t4, windows.Get(2).Get(0), 3)
    return Eq[int](t5, windows.Get(2).Get(2), 5)
}

// Test very large prepend count (stress test prefix consolidation)
func TestArrayMassivePrepend(t T) T {
    var arr = EmptyArray[int]()
    // Prepend 200 elements - forces about 6 consolidations
    for i := 200; i >= 1; i-- {
        arr = arr.Prepend(i)
    }

    var t1 = Eq[int](t, arr.Length(), 200)
    var allCorrect = true
    for i := 0; i < 200; i++ {
        if arr.Get(i) != (i + 1) {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}

// Test interleaved prepend/append maintains order
func TestArrayInterleavedPrependAppend(t T) T {
    var arr = ArrayOf[int](50)

    // Interleave: prepend 49, append 51, prepend 48, append 52, ...
    for i := 1; i <= 49; i++ {
        arr = arr.Prepend(50 - i)
        arr = arr.Append(50 + i)
    }

    // Should have 99 elements: 1, 2, ..., 99
    var t1 = Eq[int](t, arr.Length(), 99)

    var allCorrect = true
    for i := 0; i < 99; i++ {
        if arr.Get(i) != (i + 1) {
            allCorrect = false
        }
    }
    return IsTrue(t1, allCorrect)
}
