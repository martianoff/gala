package main

import (
    . "martianoff/gala/test"
    . "martianoff/gala/std"
    . "martianoff/gala/string_utils"
    . "martianoff/gala/collection_immutable"
)

// Test S constructor and ToString
func TestConstructor(t T) T {
    val s = S("hello")
    return Eq(t, s.ToString(), "hello")
}

// Test Length
func TestLength(t T) T = RunCases[string, int](t,
    (sub T, input string, expected int) => Eq(sub, S(input).Length(), expected),
    Case[string, int](Name = "hello", Input = "hello", Expected = 5),
    Case[string, int](Name = "empty", Input = "", Expected = 0),
    Case[string, int](Name = "abc", Input = "abc", Expected = 3),
)

// Test IsEmpty and NonEmpty
func TestIsEmptyNonEmpty(t T) T {
    val t1 = IsTrue(t, S("").IsEmpty())
    val t2 = IsFalse(t1, S("hello").IsEmpty())
    val t3 = IsFalse(t2, S("").NonEmpty())
    return IsTrue(t3, S("hello").NonEmpty())
}

// Test CharAt
func TestCharAt(t T) T {
    val s = S("hello")
    val t1 = Eq(t, s.CharAt(0).GetOrElse('?'), 'h')
    val t2 = Eq(t1, s.CharAt(4).GetOrElse('?'), 'o')
    val t3 = IsNone(t2, s.CharAt(5))
    return IsNone(t3, s.CharAt(-1))
}

// Test Substring
func TestSubstring(t T) T {
    val s = S("hello world")
    val t1 = Eq(t, s.Substring(0, 5).ToString(), "hello")
    val t2 = Eq(t1, s.Substring(6, 11).ToString(), "world")
    val t3 = Eq(t2, s.Substring(0, 0).ToString(), "")
    return Eq(t3, s.Substring(6, 100).ToString(), "world")
}

// Test Take
func TestTake(t T) T {
    val s = S("hello")
    return RunCases[int, string](t,
        (sub T, n int, expected string) => Eq(sub, s.Take(n).ToString(), expected),
        Case[int, string](Name = "take 3", Input = 3, Expected = "hel"),
        Case[int, string](Name = "take 0", Input = 0, Expected = ""),
        Case[int, string](Name = "take 10", Input = 10, Expected = "hello"),
        Case[int, string](Name = "take -1", Input = -1, Expected = ""),
    )
}

// Test TakeRight
func TestTakeRight(t T) T {
    val s = S("hello")
    return RunCases[int, string](t,
        (sub T, n int, expected string) => Eq(sub, s.TakeRight(n).ToString(), expected),
        Case[int, string](Name = "take right 3", Input = 3, Expected = "llo"),
        Case[int, string](Name = "take right 0", Input = 0, Expected = ""),
        Case[int, string](Name = "take right 10", Input = 10, Expected = "hello"),
    )
}

// Test Drop
func TestDrop(t T) T {
    val s = S("hello")
    return RunCases[int, string](t,
        (sub T, n int, expected string) => Eq(sub, s.Drop(n).ToString(), expected),
        Case[int, string](Name = "drop 2", Input = 2, Expected = "llo"),
        Case[int, string](Name = "drop 0", Input = 0, Expected = "hello"),
        Case[int, string](Name = "drop 10", Input = 10, Expected = ""),
    )
}

// Test DropRight
func TestDropRight(t T) T {
    val s = S("hello")
    return RunCases[int, string](t,
        (sub T, n int, expected string) => Eq(sub, s.DropRight(n).ToString(), expected),
        Case[int, string](Name = "drop right 2", Input = 2, Expected = "hel"),
        Case[int, string](Name = "drop right 0", Input = 0, Expected = "hello"),
        Case[int, string](Name = "drop right 10", Input = 10, Expected = ""),
    )
}

// Test ToUpper and ToLower
func TestCase(t T) T {
    val t1 = Eq(t, S("Hello World").ToUpper().ToString(), "HELLO WORLD")
    return Eq(t1, S("Hello World").ToLower().ToString(), "hello world")
}

// Test Trim
func TestTrim(t T) T {
    val s = S("  hello  ")
    val t1 = Eq(t, s.Trim().ToString(), "hello")
    val t2 = Eq(t1, s.TrimLeft().ToString(), "hello  ")
    return Eq(t2, s.TrimRight().ToString(), "  hello")
}

// Test TrimPrefix and TrimSuffix
func TestTrimPrefixSuffix(t T) T {
    val s = S("hello world")
    val t1 = Eq(t, s.TrimPrefix("hello ").ToString(), "world")
    val t2 = Eq(t1, s.TrimSuffix(" world").ToString(), "hello")
    return Eq(t2, s.TrimPrefix("xyz").ToString(), "hello world")
}

// Test Replace
func TestReplace(t T) T {
    val s = S("hello hello")
    val t1 = Eq(t, s.Replace("hello", "hi").ToString(), "hi hello")
    return Eq(t1, s.ReplaceAll("hello", "hi").ToString(), "hi hi")
}

// Test Reverse
func TestReverse(t T) T = RunCases[string, string](t,
    (sub T, input string, expected string) => Eq(sub, S(input).Reverse().ToString(), expected),
    Case[string, string](Name = "hello", Input = "hello", Expected = "olleh"),
    Case[string, string](Name = "empty", Input = "", Expected = ""),
    Case[string, string](Name = "single", Input = "a", Expected = "a"),
)

// Test Repeat
func TestRepeat(t T) T {
    val s = S("ab")
    return RunCases[int, string](t,
        (sub T, n int, expected string) => Eq(sub, s.Repeat(n).ToString(), expected),
        Case[int, string](Name = "repeat 3", Input = 3, Expected = "ababab"),
        Case[int, string](Name = "repeat 0", Input = 0, Expected = ""),
        Case[int, string](Name = "repeat 1", Input = 1, Expected = "ab"),
    )
}

// Test PadLeft and PadRight
func TestPadding(t T) T {
    val t1 = Eq(t, S("42").PadLeft(5, '0').ToString(), "00042")
    val t2 = Eq(t1, S("hi").PadRight(5, '-').ToString(), "hi---")
    val t3 = Eq(t2, S("hello").PadLeft(3, 'x').ToString(), "hello")
    return Eq(t3, S("a").Center(5, '-').ToString(), "--a--")
}

// Test Capitalize and Uncapitalize
func TestCapitalize(t T) T {
    val t1 = Eq(t, S("hello").Capitalize().ToString(), "Hello")
    val t2 = Eq(t1, S("Hello").Uncapitalize().ToString(), "hello")
    val t3 = Eq(t2, S("").Capitalize().ToString(), "")
    return Eq(t3, S("").Uncapitalize().ToString(), "")
}

// Test Split
func TestSplit(t T) T {
    val parts = S("a,b,c").Split(",")
    val t1 = Eq(t, parts.Length(), 3)
    val t2 = Eq(t1, parts.Get(0).ToString(), "a")
    val t3 = Eq(t2, parts.Get(1).ToString(), "b")
    return Eq(t3, parts.Get(2).ToString(), "c")
}

// Test SplitAt
func TestSplitAt(t T) T {
    val (first, second) = S("hello").SplitAt(2)
    val t1 = Eq(t, first.ToString(), "he")
    return Eq(t1, second.ToString(), "llo")
}

// Test Lines
func TestLines(t T) T {
    val lines = S("line1\nline2\nline3").Lines()
    val t1 = Eq(t, lines.Length(), 3)
    val t2 = Eq(t1, lines.Get(0).ToString(), "line1")
    return Eq(t2, lines.Get(2).ToString(), "line3")
}

// Test Words
func TestWords(t T) T {
    val words = S("hello  world\tfoo").Words()
    val t1 = Eq(t, words.Length(), 3)
    val t2 = Eq(t1, words.Get(0).ToString(), "hello")
    return Eq(t2, words.Get(2).ToString(), "foo")
}

// Test Join
func TestJoin(t T) T {
    val strs = ArrayOf(S("a"), S("b"), S("c"))
    val t1 = Eq(t, Join(strs, ", ").ToString(), "a, b, c")
    return Eq(t1, Join(EmptyArray[Str](), ", ").ToString(), "")
}

// Test Contains
func TestContains(t T) T {
    val s = S("hello world")
    val t1 = IsTrue(t, s.Contains("world"))
    val t2 = IsFalse(t1, s.Contains("xyz"))
    val t3 = IsTrue(t2, s.ContainsAny("aeiou"))
    return IsFalse(t3, s.ContainsAny("xyz"))
}

// Test StartsWith and EndsWith
func TestStartsEndsWith(t T) T {
    val s = S("hello world")
    val t1 = IsTrue(t, s.StartsWith("hello"))
    val t2 = IsFalse(t1, s.StartsWith("world"))
    val t3 = IsTrue(t2, s.EndsWith("world"))
    return IsFalse(t3, s.EndsWith("hello"))
}

// Test IsAlpha, IsNumeric, IsAlphanumeric
func TestCharacterPredicates(t T) T {
    val t1 = IsTrue(t, S("hello").IsAlpha())
    val t2 = IsFalse(t1, S("hello1").IsAlpha())
    val t3 = IsTrue(t2, S("12345").IsNumeric())
    val t4 = IsFalse(t3, S("123a5").IsNumeric())
    val t5 = IsTrue(t4, S("hello123").IsAlphanumeric())
    val t6 = IsFalse(t5, S("hello 123").IsAlphanumeric())
    val t7 = IsTrue(t6, S("   \t").IsWhitespace())
    return IsFalse(t7, S("").IsAlpha())
}

// Test IsUpper and IsLower
func TestCasePredicates(t T) T {
    val t1 = IsTrue(t, S("HELLO").IsUpper())
    val t2 = IsFalse(t1, S("Hello").IsUpper())
    val t3 = IsTrue(t2, S("hello").IsLower())
    val t4 = IsFalse(t3, S("Hello").IsLower())
    val t5 = IsTrue(t4, S("HELLO 123").IsUpper())
    return IsTrue(t5, S("hello 123").IsLower())
}

// Test IndexOf
func TestIndexOf(t T) T {
    val s = S("hello world")
    val t1 = Eq(t, s.IndexOf("world").GetOrElse(-1), 6)
    val t2 = IsNone(t1, s.IndexOf("xyz"))
    return Eq(t2, s.LastIndexOf("o").GetOrElse(-1), 7)
}

// Test Count
func TestCount(t T) T {
    val t1 = Eq(t, S("hello").Count("l"), 2)
    return Eq(t1, S("hello").Count("x"), 0)
}

// Test ToChars
func TestToChars(t T) T {
    val chars = S("hi").ToChars()
    val t1 = Eq(t, chars.Length(), 2)
    val t2 = Eq(t1, chars.Get(0), 'h')
    return Eq(t2, chars.Get(1), 'i')
}

// Test Concat and Plus
func TestConcat(t T) T {
    val s1 = S("hello")
    val s2 = S(" world")
    val t1 = Eq(t, s1.Concat(s2).ToString(), "hello world")
    return Eq(t1, s1.Plus(s2).ToString(), "hello world")
}

// Test Map
func TestMap(t T) T {
    val s = S("abc")
    val result = s.Map((r rune) => r + 1)
    return Eq(t, result.ToString(), "bcd")
}

// Test Filter
func TestFilter(t T) T {
    val s = S("hello world")
    val result = s.Filter((r rune) => r != ' ')
    return Eq(t, result.ToString(), "helloworld")
}

// Test Fold (via Length since Fold[U] is a generic method)
func TestFold(t T) T {
    val s = S("hello")
    return Eq(t, s.Length(), 5)
}

// Test Exists and ForAll
func TestExistsForAll(t T) T {
    val s = S("hello")
    val t1 = IsTrue(t, s.Exists((r rune) => r == 'l'))
    val t2 = IsFalse(t1, s.Exists((r rune) => r == 'x'))
    val t3 = IsTrue(t2, s.ForAll((r rune) => r >= 'a' && r <= 'z'))
    return IsFalse(t3, s.ForAll((r rune) => r == 'h'))
}

// Test Find
func TestFind(t T) T {
    val s = S("hello")
    val t1 = Eq(t, s.Find((r rune) => r == 'l').GetOrElse('?'), 'l')
    return IsNone(t1, s.Find((r rune) => r == 'x'))
}

// Test ZipWithIndex
func TestZipWithIndex(t T) T {
    val s = S("ab")
    val result = s.ZipWithIndex()
    val t1 = Eq(t, result.Length(), 2)
    val (r0, i0) = result.Get(0)
    val (r1, i1) = result.Get(1)
    val t2 = Eq(t1, r0, 'a')
    val t3 = Eq(t2, i0, 0)
    val t4 = Eq(t3, r1, 'b')
    return Eq(t4, i1, 1)
}

// Test Equals and EqualsIgnoreCase
func TestEquals(t T) T {
    val t1 = IsTrue(t, S("hello").Equals(S("hello")))
    val t2 = IsFalse(t1, S("hello").Equals(S("HELLO")))
    val t3 = IsTrue(t2, S("hello").EqualsIgnoreCase(S("HELLO")))
    return IsTrue(t3, S("hello").EqualsIgnoreCase(S("HeLLo")))
}

// Test Compare
func TestCompare(t T) T {
    val t1 = Eq(t, S("abc").Compare(S("abc")), 0)
    val t2 = Eq(t1, S("abc").Compare(S("abd")), -1)
    return Eq(t2, S("abd").Compare(S("abc")), 1)
}

// Test chained operations
func TestChainedOperations(t T) T {
    val result = S("  Hello, World!  ")
        .Trim()
        .ToLower()
        .ReplaceAll(",", "")
        .ReplaceAll("!", "")
    return Eq(t, result.ToString(), "hello world")
}

// Test NewStringBuilder
func TestNewStringBuilder(t T) T {
    val sb = NewStringBuilder()
    val t1 = IsTrue(t, sb.IsEmpty())
    val t2 = Eq(t1, sb.Length(), 0)
    return Eq(t2, sb.ToString(), "")
}

// Test NewStringBuilderFrom
func TestNewStringBuilderFrom(t T) T {
    val sb = NewStringBuilderFrom(S("hello"))
    val t1 = IsFalse(t, sb.IsEmpty())
    return Eq(t1, sb.ToString(), "hello")
}

// Test NewStringBuilderFromString
func TestNewStringBuilderFromString(t T) T {
    val sb = NewStringBuilderFromString("hello")
    return Eq(t, sb.ToString(), "hello")
}

// Test Append with Str
func TestStringBuilderAppend(t T) T {
    val sb = NewStringBuilder()
    sb.Append(S("hello"))
    sb.Append(S(" world"))
    return Eq(t, sb.ToString(), "hello world")
}

// Test chaining
func TestStringBuilderChaining(t T) T {
    val result = NewStringBuilder()
        .AppendString("hello")
        .AppendString(" ")
        .AppendString("world")
        .ToString()
    return Eq(t, result, "hello world")
}

// Test AppendString
func TestStringBuilderAppendString(t T) T {
    val sb = NewStringBuilder()
    sb.AppendString("abc")
    sb.AppendString("def")
    return Eq(t, sb.ToString(), "abcdef")
}

// Test AppendRune
func TestStringBuilderAppendRune(t T) T {
    val sb = NewStringBuilder()
    sb.AppendRune('a')
    sb.AppendRune('b')
    sb.AppendRune('c')
    return Eq(t, sb.ToString(), "abc")
}

// Test AppendLine
func TestStringBuilderAppendLine(t T) T {
    val sb = NewStringBuilder()
    sb.AppendLine(S("line1"))
    sb.AppendLine(S("line2"))
    return Eq(t, sb.ToString(), "line1\nline2\n")
}

// Test AppendStringLine
func TestStringBuilderAppendStringLine(t T) T {
    val sb = NewStringBuilder()
    sb.AppendStringLine("line1")
    sb.AppendStringLine("line2")
    return Eq(t, sb.ToString(), "line1\nline2\n")
}

// Test ToStr
func TestStringBuilderToStr(t T) T {
    val sb = NewStringBuilderFromString("hello")
    val s = sb.ToStr()
    val t1 = Eq(t, s.ToString(), "hello")
    return Eq(t1, s.Length(), 5)
}

// Test Reset
func TestStringBuilderReset(t T) T {
    val sb = NewStringBuilderFromString("hello")
    sb.Reset()
    val t1 = IsTrue(t, sb.IsEmpty())
    return Eq(t1, sb.ToString(), "")
}

// Test NonEmpty
func TestStringBuilderNonEmpty(t T) T {
    val sb = NewStringBuilder()
    val t1 = IsFalse(t, sb.NonEmpty())
    sb.AppendString("x")
    return IsTrue(t1, sb.NonEmpty())
}

// Test RuneCount
func TestStringBuilderRuneCount(t T) T {
    val sb = NewStringBuilderFromString("hello")
    return Eq(t, sb.RuneCount(), 5)
}

// Test Length (byte length)
func TestStringBuilderLength(t T) T {
    val sb = NewStringBuilderFromString("hello")
    return Eq(t, sb.Length(), 5)
}
